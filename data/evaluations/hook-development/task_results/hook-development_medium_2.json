{
  "task_id": "hook-development_medium_2",
  "prompt": "Create a hook system that automatically runs code quality checks after any file edit and provides feedback to Claude about potential issues.",
  "difficulty": "medium",
  "model": "claude-3-5-haiku-20241022",
  "response": "I'll create a comprehensive hook system for code quality checks. I'll generate multiple files for a complete implementation.\n\nFirst, I'll create the `hooks.json` to configure the hook:\n\n```python\nimport os\nimport json\n\nhooks_config = {\n    \"description\": \"Code Quality Checks for File Edits\",\n    \"hooks\": {\n        \"PostToolUse\": [\n            {\n                \"matcher\": \"Edit\",\n                \"hooks\": [\n                    {\n                        \"type\": \"command\",\n                        \"command\": \"${CLAUDE_PLUGIN_ROOT}/code_quality_check.py\"\n                    }\n                ]\n            }\n        ]\n    }\n}\n\n# Use OUTPUT_DIR from environment\noutput_dir = os.environ.get('OUTPUT_DIR', '/tmp')\nhooks_path = os.path.join(output_dir, 'hooks.json')\n\nwith open(hooks_path, 'w') as f:\n    json.dump(hooks_config, f, indent=2)\nprint(f\"Created hooks configuration at {hooks_path}\")\n```\n\nNext, I'll create the code quality check script:\n\n```python\nimport os\nimport json\nimport sys\nimport subprocess\nimport pylint.lint\nfrom pylint.reporters.json import JSONReporter\n\ndef run_pylint(file_path):\n    \"\"\"Run Pylint on the given file and return JSON report.\"\"\"\n    # Use StringIO to capture JSON output\n    from io import StringIO\n    json_output = StringIO()\n    reporter = JSONReporter(json_output)\n    \n    try:\n        # Run Pylint with JSON reporter\n        pylint.lint.Run([file_path, '--output-format=json'], reporter=reporter, exit=False)\n        json_output.seek(0)\n        return json.load(json_output)\n    except Exception as e:\n        return {\"error\": str(e)}\n\ndef run_bandit(file_path):\n    \"\"\"Run Bandit security linter on the given file.\"\"\"\n    try:\n        result = subprocess.run(\n            ['bandit', '-f', 'json', file_path], \n            capture_output=True, \n            text=True\n        )\n        return json.loads(result.stdout)\n    except Exception as e:\n        return {\"error\": str(e)}\n\ndef main():\n    # Read hook input from stdin\n    hook_input = json.load(sys.stdin)\n    \n    # Only process Edit tool results\n    if hook_input.get('tool_name') != 'Edit':\n        print(json.dumps({\n            \"continue\": True,\n            \"systemMessage\": \"Not an Edit operation, skipping checks.\"\n        }))\n        sys.exit(0)\n    \n    # Extract file path from Edit tool result\n    edited_file = hook_input.get('tool_input', {}).get('file_path', '')\n    \n    # Validate file path\n    if not edited_file or not os.path.isfile(edited_file):\n        print(json.dumps({\n            \"continue\": True,\n            \"systemMessage\": f\"Invalid file path: {edited_file}\"\n        }))\n        sys.exit(0)\n    \n    # Check file extension (only for Python for now)\n    if not edited_file.endswith('.py'):\n        print(json.dumps({\n            \"continue\": True,\n            \"systemMessage\": \"Skipping checks for non-Python file.\"\n        }))\n        sys.exit(0)\n    \n    # Run code quality checks\n    pylint_results = run_pylint(edited_file)\n    bandit_results = run_bandit(edited_file)\n    \n    # Prepare comprehensive feedback\n    issues = []\n    \n    # Process Pylint results\n    if isinstance(pylint_results, list):\n        issues.extend([\n            f\"Pylint: {issue['type']} at {issue['path']}:{issue['line']}: {issue['message']}\"\n            for issue in pylint_results if issue['type'] != 'convention'\n        ])\n    \n    # Process Bandit results\n    if isinstance(bandit_results, dict) and 'results' in bandit_results:\n        issues.extend([\n            f\"Security Issue: {issue['issue_text']} (Severity: {issue['issue_severity']})\"\n            for issue in bandit_results['results']\n        ])\n    \n    # Prepare output\n    if issues:\n        output = {\n            \"continue\": True,\n            \"systemMessage\": \"Code Quality Check Findings:\\n\" + \"\\n\".join(issues)\n        }\n    else:\n        output = {\n            \"continue\": True,\n            \"systemMessage\": \"\u2705 No significant code quality issues detected.\"\n        }\n    \n    print(json.dumps(output))\n\nif __name__ == \"__main__\":\n    main()\n```\n\nNow, I'll create a requirements file for dependencies:\n\n```python\nimport os\n\nrequirements_content = \"\"\"\npylint\nbandit\n\"\"\"\n\n# Use OUTPUT_DIR from environment\noutput_dir = os.environ.get('OUTPUT_DIR', '/tmp')\nrequirements_path = os.path.join(output_dir, 'requirements.txt')\n\nwith open(requirements_path, 'w') as f:\n    f.write(requirements_content)\nprint(f\"Created requirements file at {requirements_path}\")\n```\n\nLastly, I'll create a README to explain the hook:\n\n```python\nimport os\n\nreadme_content = \"\"\"# Code Quality Hooks\n\n## Overview\nThis hook automatically runs code quality checks after file edits, providing instant feedback about potential issues.\n\n## Checks Performed\n- Pylint: Code style and potential errors\n- Bandit: Security vulnerability scanning\n\n## Requirements\n- Python 3.7+\n- pylint\n- bandit\n\n## Installation\npip install -r requirements.txt\n\n## Behavior\n- Runs automatically on Edit tool for Python files\n- Returns detailed feedback about code quality issues\n- Helps maintain code standards and security\n\"\"\"\n\n# Use OUTPUT_DIR from environment\noutput_dir = os.environ.get('OUTPUT_DIR', '/tmp')\nreadme_path = os.path.join(output_dir, 'README.md')\n\nwith open(readme_path, 'w') as f:\n    f.write(readme_content)\nprint(f\"Created README at {readme_path}\")\n```\n\nThese scripts together create a comprehensive hook system that:\n1. Configures a hook for file edits\n2. Runs Pylint for code quality checks\n3. Runs Bandit for security vulnerability scanning\n4. Provides feedback to Claude\n5. Skips non-Python files\n6. Has a clear README explaining the system\n\nWould you like me to elaborate on any part of the implementation?",
  "criteria_results": {
    "file_created": false,
    "file_valid": false,
    "file_has_content": false
  },
  "verification_notes": {
    "file_created": "verified",
    "file_valid": "verified - no file created",
    "file_has_content": "verified - no file created"
  },
  "verification_level": "full",
  "verified_criteria": {
    "passed": 0,
    "total": 1
  },
  "passed": false,
  "tokens": {
    "input": 4836,
    "output": 1602,
    "total": 6438
  },
  "execution_time": 24.269809246063232,
  "error": null,
  "timestamp": "2026-01-01T18:54:38.191110"
}