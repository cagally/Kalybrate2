{
  "task_id": "mcp-integration_easy_1",
  "prompt": "I want to add MCP server support to my plugin so it can connect to a file system. Can you show me how to set this up?",
  "difficulty": "easy",
  "model": "claude-3-5-haiku-20241022",
  "response": "I'll help you set up an MCP server for file system access using a stdio-based MCP server. I'll provide a comprehensive example that covers the configuration and implementation.\n\n1. First, let's create the MCP configuration (`.mcp.json`):\n\n```json\n{\n  \"filesystem\": {\n    \"command\": \"python\",\n    \"args\": [\"-m\", \"mcp_filesystem_server\"],\n    \"env\": {\n      \"MCP_FILESYSTEM_ROOT\": \"${CLAUDE_PLUGIN_ROOT}/data\",\n      \"LOG_LEVEL\": \"info\"\n    }\n  }\n}\n```\n\n2. Now, let's create the MCP filesystem server (`mcp_filesystem_server.py`):\n\n```python\nimport os\nimport sys\nimport json\nimport shutil\nimport logging\nfrom typing import Dict, Any\n\nclass FileSystemMCPServer:\n    def __init__(self, root_path: str):\n        self.root_path = os.path.abspath(root_path)\n        logging.basicConfig(level=logging.INFO)\n        self.logger = logging.getLogger('mcp_filesystem_server')\n        \n        # Ensure root path exists\n        os.makedirs(self.root_path, exist_ok=True)\n        self.logger.info(f\"Filesystem MCP server initialized with root: {self.root_path}\")\n\n    def _validate_path(self, relative_path: str) -> str:\n        \"\"\"\n        Validate and sanitize the input path to prevent directory traversal\n        \"\"\"\n        full_path = os.path.normpath(os.path.join(self.root_path, relative_path))\n        \n        # Ensure the path is within the root directory\n        if not full_path.startswith(self.root_path):\n            raise ValueError(\"Invalid path: Access outside root directory is not allowed\")\n        \n        return full_path\n\n    def list_files(self, path: str = '.') -> Dict[str, Any]:\n        \"\"\"\n        List files and directories in the given path\n        \"\"\"\n        try:\n            full_path = self._validate_path(path)\n            contents = []\n            \n            for item in os.listdir(full_path):\n                item_path = os.path.join(full_path, item)\n                contents.append({\n                    'name': item,\n                    'type': 'directory' if os.path.isdir(item_path) else 'file',\n                    'size': os.path.getsize(item_path) if os.path.isfile(item_path) else None,\n                    'modified': os.path.getmtime(item_path)\n                })\n            \n            return {\n                'path': path,\n                'contents': contents\n            }\n        except Exception as e:\n            self.logger.error(f\"Error listing files: {e}\")\n            return {'error': str(e)}\n\n    def read_file(self, path: str, encoding: str = 'utf-8') -> Dict[str, Any]:\n        \"\"\"\n        Read contents of a file\n        \"\"\"\n        try:\n            full_path = self._validate_path(path)\n            \n            with open(full_path, 'r', encoding=encoding) as f:\n                content = f.read()\n            \n            return {\n                'path': path,\n                'content': content\n            }\n        except Exception as e:\n            self.logger.error(f\"Error reading file: {e}\")\n            return {'error': str(e)}\n\n    def write_file(self, path: str, content: str, encoding: str = 'utf-8') -> Dict[str, Any]:\n        \"\"\"\n        Write content to a file\n        \"\"\"\n        try:\n            full_path = self._validate_path(path)\n            \n            # Ensure directory exists\n            os.makedirs(os.path.dirname(full_path), exist_ok=True)\n            \n            with open(full_path, 'w', encoding=encoding) as f:\n                f.write(content)\n            \n            return {\n                'path': path,\n                'status': 'success'\n            }\n        except Exception as e:\n            self.logger.error(f\"Error writing file: {e}\")\n            return {'error': str(e)}\n\n    def delete_file(self, path: str) -> Dict[str, Any]:\n        \"\"\"\n        Delete a file or directory\n        \"\"\"\n        try:\n            full_path = self._validate_path(path)\n            \n            if os.path.isdir(full_path):\n                shutil.rmtree(full_path)\n            else:\n                os.remove(full_path)\n            \n            return {\n                'path': path,\n                'status': 'deleted'\n            }\n        except Exception as e:\n            self.logger.error(f\"Error deleting file/directory: {e}\")\n            return {'error': str(e)}\n\ndef main():\n    # Get root path from environment variable\n    root_path = os.environ.get('MCP_FILESYSTEM_ROOT', '/tmp/mcp-filesystem')\n    server = FileSystemMCPServer(root_path)\n\n    # MCP communication loop\n    while True:\n        try:\n            # Read input from stdin\n            line = sys.stdin.readline().strip()\n            if not line:\n                continue\n\n            # Parse JSON input\n            try:\n                request = json.loads(line)\n            except json.JSONDecodeError:\n                print(json.dumps({'error': 'Invalid JSON'}))\n                continue\n\n            # Dispatch method\n            method = request.get('method')\n            params = request.get('params', {})\n\n            response = {'id': request.get('id')}\n            try:\n                if method == 'list_files':\n                    response['result'] = server.list_files(params.get('path', '.'))\n                elif method == 'read_file':\n                    response['result'] = server.read_file(\n                        params['path'], \n                        params.get('encoding', 'utf-8')\n                    )\n                elif method == 'write_file':\n                    response['result'] = server.write_file(\n                        params['path'], \n                        params['content'], \n                        params.get('encoding', 'utf-8')\n                    )\n                elif method == 'delete_file':\n                    response['result'] = server.delete_file(params['path'])\n                else:\n                    response['error'] = f'Unknown method: {method}'\n            except Exception as e:\n                response['error'] = str(e)\n\n            # Send response\n            print(json.dumps(response))\n            sys.stdout.flush()\n\n        except Exception as e:\n            print(json.dumps({'error': str(e)}))\n            sys.stdout.flush()\n\nif __name__ == '__main__':\n    main()\n```\n\n3. Create a `requirements.txt` file to manage dependencies:\n\n```\n# This server has no external dependencies\n```\n\n4. Update your `plugin.json` to include MCP configuration:\n\n```json\n{\n  \"name\": \"filesystem-plugin\",\n  \"version\": \"1.0.0\",\n  \"description\": \"File system access via MCP\",\n  \"mcpServers\": {\n    \"filesystem\": {\n      \"command\": \"python\",\n      \"args\": [\"-m\", \"mcp_filesystem_server\"]\n    }\n  }\n}\n```\n\n5. Create a README with setup instructions:\n\n```markdown\n# Filesystem MCP Plugin\n\n## Setup\n\n### Environment Variables\n\n- `MCP_FILESYSTEM_ROOT`: Root directory for file system access (default: plugin's data directory)\n\n### Required Permissions\n\nThis plugin requires read/write access to the specified root directory.\n\n## Available Tools\n\n- `mcp__plugin_filesystem_filesystem__list_files`: List files in a directory\n- `mcp__plugin_filesystem_filesystem__read_file`: Read file contents\n- `mcp__plugin_filesystem_filesystem__write_file`: Write file contents\n- `mcp__plugin_filesystem_filesystem__delete_file`: Delete files/directories\n\n## Security Notes\n\n- Access is restricted to the specified root directory\n- Path traversal is prevented\n```\n\n### Usage Example in a Command\n\nHere's an example of how you might use this MCP filesystem server in a command:\n\n```markdown\n---\nallowed-tools: [\n  \"mcp__plugin_filesystem_filesystem__list_files\",\n  \"mcp__plugin_filesystem_filesystem__read_file\",\n  \"mcp__plugin_filesystem_filesystem__write_file\"\n]\n---\n\n# List files in the data directory\n- Use mcp__plugin_filesystem_filesystem__list_files to show contents\n- Optionally read or write files as needed\n```\n\n### Best Practices and Notes\n\n1. The server uses stdio for communication\n2. It implements basic file system operations with security checks\n3. Logging is configured to help with debugging\n4. Path validation prevents directory traversal attacks\n5. The root directory can be configured via environment variable\n\nTo test:\n- Ensure Python is installed\n- Make sure the script is executable\n- Run Claude Code with the plugin\n- Use `/mcp` to verify the server is loaded\n\nWould you like me to elaborate on any part of the implementation or explain how to use the MCP filesystem server?",
  "criteria_results": {
    "code_extracted": true
  },
  "verification_notes": {
    "code_extracted": "verified"
  },
  "verification_level": "full",
  "verified_criteria": {
    "passed": 1,
    "total": 1
  },
  "passed": true,
  "tokens": {
    "input": 3695,
    "output": 2219,
    "total": 5914
  },
  "execution_time": 32.33707594871521,
  "error": null,
  "timestamp": "2026-01-01T19:02:31.378920"
}