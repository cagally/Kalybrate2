{
  "prompt": "What's the proper way to handle authentication and security when connecting plugins to external services?",
  "baseline_response": "When handling authentication and security for plugins connecting to external services, here are some best practices:\n\n1. Secure Credential Storage\n```python\n# Bad: Hardcoding credentials\nAPI_KEY = \"my-secret-key\"\n\n# Good: Use secure credential management\nimport os\nfrom cryptography.fernet import Fernet\n\ndef get_encrypted_credential(service_name):\n    # Store encrypted credentials in secure environment variables\n    encrypted_key = os.environ.get(f'{service_name.upper()}_ENCRYPTED_CREDENTIAL')\n    \n    # Use a secure key management system\n    encryption_key = os.environ.get('ENCRYPTION_KEY')\n    \n    # Decrypt and return credentials\n    f = Fernet(encryption_key)\n    decrypted_credential = f.decrypt(encrypted_key.encode()).decode()\n    return decrypted_credential\n```\n\n2. OAuth 2.0 Authentication\n```python\nimport requests\nfrom requests_oauthlib import OAuth2Session\n\nclass ExternalServiceClient:\n    def __init__(self, client_id, client_secret):\n        self.client_id = client_id\n        self.client_secret = client_secret\n        self.oauth = None\n    \n    def authenticate(self):\n        # OAuth 2.0 flow\n        oauth = OAuth2Session(self.client_id)\n        authorization_base_url = 'https://provider.com/oauth/authorize'\n        token_url = 'https://provider.com/oauth/token'\n        \n        # Get authorization URL\n        authorization_url, state = oauth.authorization_url(authorization_base_url)\n        \n        # User would typically open this URL and authorize\n        print(f'Please go to {authorization_url} and authorize')\n        \n        # Exchange authorization code for token\n        token = oauth.fetch_token(\n            token_url, \n            client_secret=self.client_secret,\n            authorization_response=input('Enter the full callback URL: ')\n        )\n        \n        self.oauth = oauth\n        return token\n```\n\n3. API Token Management\n```python\nclass SecureAPIClient:\n    def __init__(self):\n        self.token = None\n        self.token_expiration = None\n    \n    def _is_token_valid(self):\n        # Check if token is still valid\n        return self.token and datetime.now() < self.token_expiration\n    \n    def _refresh_token(self):\n        # Implement secure token refresh mechanism\n        try:\n            response = requests.post('https://api.example.com/refresh', \n                headers={\n                    'Authorization': f'Bearer {self.token}',\n                    'Content-Type': 'application/json'\n                }\n            )\n            new_token_data = response.json()\n            self.token = new_token_data['access_token']\n            self.token_expiration = datetime.now() + timedelta(hours=1)\n        except Exception as e:\n            # Handle token refresh failure\n            self.token = None\n            raise AuthenticationError(\"Could not refresh token\")\n    \n    def make_authenticated_request(self, url, method='get', **kwargs):\n        # Ensure valid token before making request\n        if not self._is_token_valid():\n            self._refresh_token()\n        \n        headers = kwargs.get('headers', {})\n        headers['Authorization'] = f'Bearer {self.token}'\n        kwargs['headers'] = headers\n        \n        return requests.request(method, url, **kwargs)\n```\n\n4. Secure Configuration Management\n```python\nimport configparser\nimport os\n\nclass SecureConfigManager:\n    def __init__(self, config_path=None):\n        self.config = self._load_config(config_path)\n    \n    def _load_config(self, config_path=None):\n        # Prioritize environment variables over config file\n        config = configparser.ConfigParser()\n        \n        # Try to load from environment first\n        env_config = {\n            'api_key': os.environ.get('SERVICE_API_KEY'),\n            'api_secret': os.environ.get('SERVICE_API_SECRET')\n        }\n        \n        # Fallback to config file if env vars not set\n        if not all(env_config.values()):\n            config_path = config_path or os.path.expanduser('~/.myapp/config.ini')\n            config.read(config_path)\n            # Additional security: set strict file permissions\n            os.chmod(config_path, 0o600)  # Read/write for owner only\n        \n        return env_config or dict(config['DEFAULT'])\n    \n    def get_credential(self, key):\n        # Safely retrieve credentials\n        return self.config.get(key)\n```\n\n5. Input Validation and Sanitization\n```python\nimport re\nimport html\n\ndef sanitize_input(input_string):\n    # Remove potentially dangerous characters\n    sanitized = re.sub(r'[<>&\\'\"()]', '', input_string)\n    \n    # Encode to prevent XSS\n    sanitized = html.escape(sanitized)\n    \n    return sanitized\n\ndef validate_api_key(api_key):\n    # Implement strict validation\n    if not api_key:\n        raise ValueError(\"API key cannot be empty\")\n    \n    if not re.match(r'^[a-zA-Z0-9_-]{20,50}$', api_key):\n        raise ValueError(\"Invalid API key format\")\n    \n    return True\n```\n\nKey Security Principles:\n- Never store credentials in code\n- Use environment variables or secure credential managers\n- Implement token rotation and refresh mechanisms\n- Use HTTPS for all API communications\n- Validate and sanitize all inputs\n- Implement proper error handling\n- Use OAuth 2.0 or similar secure authentication protocols\n- Protect against common security vulnerabilities\n\nAdditional Recommendations:\n- Use HTTPS with certificate pinning\n- Implement rate limiting\n- Add logging for authentication attempts\n- Use multi-factor authentication where possible\n- Regularly rotate credentials\n- Implement proper error handling and logging\n\nError Handling Example:\n```python\nclass AuthenticationError(Exception):\n    \"\"\"Custom exception for authentication failures\"\"\"\n    pass\n\ndef secure_api_call(client):\n    try:\n        response = client.make_authenticated_request('/some/endpoint')\n        response.raise_for_status()\n        return response.json()\n    except requests.exceptions.HTTPError as e:\n        if e.response.status_code == 401:\n            # Unauthorized - attempt to refresh token\n            client._refresh_token()\n            # Retry the request\n            return secure_api_call(client)\n        elif e.response.status_code == 403:\n            raise AuthenticationError(\"Access forbidden\")\n        else:\n            # Log the error\n            logging.error(f\"API call failed: {e}\")\n            raise\n```\n\nThese examples demonstrate a comprehensive approach to handling authentication and security when connecting plugins to external services, covering key aspects like secure credential management, authentication flows, input validation, and error handling.",
  "baseline_tokens": {
    "input": 24,
    "output": 1677,
    "total": 1701
  },
  "skill_response": "Based on the MCP Integration skill guidelines, here's a comprehensive approach to handling authentication and security when connecting plugins to external services:\n\n1. Authentication Methods\n\n### OAuth (Recommended for Cloud Services)\n```json\n{\n  \"type\": \"sse\",\n  \"url\": \"https://api.example.com/mcp\",\n  \"oauth\": true\n}\n```\n\u2705 Pros:\n- Secure token management\n- No manual token handling\n- User-controlled access scopes\n- Automatic token refresh\n\n### Token-Based Authentication\n```json\n{\n  \"type\": \"http\",\n  \"url\": \"https://api.example.com\",\n  \"headers\": {\n    \"Authorization\": \"Bearer ${API_TOKEN}\"\n  }\n}\n```\n\u2705 Best Practices:\n- Use environment variables\n- Never hardcode tokens\n- Rotate tokens periodically\n\n2. Security Best Practices\n\n### Connection Security\n```json\n\u2705 \"url\": \"https://mcp.example.com/sse\"\n\u274c \"url\": \"http://mcp.example.com/sse\"\n```\n- Always use HTTPS/WSS\n- Verify SSL certificates\n- Implement proper encryption\n\n### Token Management\n```markdown\nDO:\n- \u2705 Use environment variables for tokens\n- \u2705 Document required env vars in README\n- \u2705 Let OAuth flow handle authentication\n\nDON'T:\n- \u274c Hardcode tokens in configuration\n- \u274c Commit tokens to git\n- \u274c Share tokens in documentation\n```\n\n### Permission Scoping\n```markdown\n# Recommended: Minimal necessary permissions\nallowed-tools: [\n  \"mcp__plugin_api_server__read_data\",\n  \"mcp__plugin_api_server__create_item\"\n]\n\n# Avoid: Overly broad access\n\u274c allowed-tools: [\"mcp__plugin_api_server__*\"]\n```\n\n3. Environment Variable Configuration\n```json\n{\n  \"command\": \"python\",\n  \"args\": [\"-m\", \"my_mcp_server\"],\n  \"env\": {\n    \"API_KEY\": \"${SECURE_API_TOKEN}\",\n    \"LOG_LEVEL\": \"info\"\n  }\n}\n```\n- Use prefixed environment variables\n- Document all required variables\n- Provide clear setup instructions\n\n4. Error Handling and Validation\n```markdown\nError Handling Checklist:\n- [ ] Validate input before API calls\n- [ ] Handle authentication failures\n- [ ] Implement retry mechanisms\n- [ ] Provide clear error messages\n- [ ] Log security-related events\n```\n\n5. Debugging and Monitoring\n```bash\n# Enable debug logging\nclaude --debug\n\n# Check for:\n- Connection attempts\n- Authentication flows\n- Potential security issues\n```\n\n6. Recommended Authentication Workflow\n```markdown\nAuthentication Process:\n1. Use OAuth for cloud services\n2. Fallback to token-based auth\n3. Store tokens securely\n4. Implement token rotation\n5. Validate and scope permissions\n6. Handle authentication errors gracefully\n```\n\n7. Security Configuration Example\n```json\n{\n  \"github\": {\n    \"type\": \"sse\",\n    \"url\": \"https://mcp.github.com/sse\",\n    \"oauth\": true,\n    \"scopes\": [\n      \"repo:read\",\n      \"user:email\"\n    ]\n  }\n}\n```\n\n8. Compliance Recommendations\n- Implement multi-factor authentication when possible\n- Use short-lived access tokens\n- Regularly audit and rotate credentials\n- Follow principle of least privilege\n\nKey Takeaways:\n1. Prioritize HTTPS connections\n2. Use environment variables for sensitive data\n3. Implement fine-grained access control\n4. Handle authentication errors gracefully\n5. Regularly review and update security practices\n\nBy following these guidelines, you'll create a robust and secure method for connecting plugins to external services while protecting sensitive authentication information.",
  "skill_tokens": {
    "input": 3656,
    "output": 924,
    "total": 4580
  },
  "judge_verdict": "with_skill",
  "judge_reasoning": "Response A provides a more comprehensive and structured approach specifically tailored to MCP (Model Context Protocol) integration with clear JSON configuration examples, security best practices, and actionable checklists. Response B offers good general programming examples but is incomplete (cuts off mid-code) and lacks the specific context and completeness that makes Response A more useful for the actual task of handling plugin authentication and security.",
  "judge_model": "claude-sonnet-4-20250514",
  "timestamp": "2026-01-01T19:05:50.337806"
}