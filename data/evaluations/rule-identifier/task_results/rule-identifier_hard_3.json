{
  "task_id": "rule-identifier_hard_3",
  "prompt": "I need to implement a rule system that can dynamically enable/disable based on context, handle all event types appropriately, and provide rich markdown-formatted guidance with code examples, warnings, and actionable suggestions.",
  "difficulty": "hard",
  "model": "claude-3-5-haiku-20241022",
  "response": "I'll help you design a comprehensive rule system with dynamic configuration and rich contextual guidance. I'll break this down into several components:\n\n1. Rule Definition Structure\n2. Rule Engine\n3. Event Handling\n4. Markdown Formatting\n5. Example Implementation\n\nHere's a robust implementation:\n\n`rule_system.py`:\n```python\nimport re\nimport os\nimport json\nfrom typing import Dict, List, Optional, Callable\nfrom dataclasses import dataclass, asdict\n\n@dataclass\nclass Rule:\n    name: str\n    enabled: bool = True\n    event_types: List[str] = None\n    pattern: Optional[str] = None\n    message: str = \"\"\n    action: Optional[Callable] = None\n\nclass RuleEngine:\n    def __init__(self, rules_dir: str = 'rules'):\n        self.rules: List[Rule] = []\n        self.rules_dir = rules_dir\n        self.load_rules()\n\n    def load_rules(self):\n        \"\"\"Load rules from markdown files in rules directory\"\"\"\n        if not os.path.exists(self.rules_dir):\n            os.makedirs(self.rules_dir)\n        \n        for filename in os.listdir(self.rules_dir):\n            if filename.endswith('.md'):\n                rule = self._parse_rule_file(os.path.join(self.rules_dir, filename))\n                if rule:\n                    self.rules.append(rule)\n\n    def _parse_rule_file(self, filepath: str) -> Optional[Rule]:\n        \"\"\"Parse a markdown rule file into a Rule object\"\"\"\n        try:\n            with open(filepath, 'r') as f:\n                content = f.read()\n                \n            # Extract rule metadata from markdown frontmatter\n            metadata_match = re.match(r'---\\n(.*?)\\n---', content, re.DOTALL)\n            if not metadata_match:\n                return None\n            \n            metadata = {}\n            for line in metadata_match.group(1).split('\\n'):\n                if ':' in line:\n                    key, value = line.split(':', 1)\n                    metadata[key.strip()] = value.strip()\n            \n            # Create Rule object\n            return Rule(\n                name=metadata.get('name', os.path.splitext(os.path.basename(filepath))[0]),\n                enabled=metadata.get('enabled', 'true').lower() == 'true',\n                event_types=metadata.get('event', 'all').split('|'),\n                pattern=metadata.get('pattern'),\n                message=content.split('---', 2)[-1].strip()\n            )\n        except Exception as e:\n            print(f\"Error parsing rule file {filepath}: {e}\")\n            return None\n\n    def check_rules(self, event_type: str, context: Dict = None) -> List[str]:\n        \"\"\"Check applicable rules for a given event type\"\"\"\n        context = context or {}\n        triggered_messages = []\n\n        for rule in self.rules:\n            # Check if rule is enabled and matches event type\n            if not rule.enabled:\n                continue\n            \n            if 'all' not in rule.event_types and event_type not in rule.event_types:\n                continue\n            \n            # Pattern matching if specified\n            if rule.pattern:\n                # Use context or event type for pattern matching\n                match_text = context.get('text', event_type)\n                if not re.search(rule.pattern, str(match_text), re.IGNORECASE):\n                    continue\n            \n            # Collect rule messages\n            triggered_messages.append(self._format_rule_message(rule))\n        \n        return triggered_messages\n\n    def _format_rule_message(self, rule: Rule) -> str:\n        \"\"\"Format rule message with markdown and contextual information\"\"\"\n        return f\"\"\"\n### {rule.name} Rule\n\n{rule.message}\n\n**Guidance:**\n- Event Type: {', '.join(rule.event_types)}\n- Pattern: `{rule.pattern or 'N/A'}`\n\"\"\"\n\n    def export_rules(self, output_file: str = 'rules_config.json'):\n        \"\"\"Export current rules configuration\"\"\"\n        rules_data = [asdict(rule) for rule in self.rules]\n        with open(output_file, 'w') as f:\n            json.dump(rules_data, f, indent=2)\n\n# Example usage\nif __name__ == '__main__':\n    engine = RuleEngine()\n    \n    # Example rule checks\n    bash_rules = engine.check_rules('bash', {'text': 'rm -rf /'})\n    file_rules = engine.check_rules('file', {'text': 'sensitive_data.txt'})\n    \n    for rule in bash_rules + file_rules:\n        print(rule)\n    \n    # Export rules configuration\n    engine.export_rules()\n```\n\nExample Rule File (`rules/rm-safety.md`):\n```markdown\n---\nname: rm-safety\nenabled: true\nevent: bash\npattern: rm\\s+-[rf]\n---\n\n**\u26a0\ufe0f CRITICAL SAFETY WARNING \u26a0\ufe0f**\n\nThe command appears to be a potentially destructive `rm` operation.\n\n**Recommended Actions:**\n- Always use full paths\n- Add confirmation prompts\n- Use `-i` for interactive mode\n- Never use `-rf /`\n\nExample Safe Usage:\n```bash\n# Safe deletion with confirmation\nrm -i /path/to/specific/file\n```\n```\n\nExample Rule File (`rules/sensitive-file.md`):\n```markdown\n---\nname: sensitive-file-protection\nenabled: true\nevent: file\npattern: (password|secret|key)\n---\n\n**\ud83d\udea8 Sensitive File Detection \ud83d\udea8**\n\nPotential sensitive file detected with high-risk naming convention.\n\n**Security Recommendations:**\n- Avoid storing credentials in plaintext\n- Use environment variables\n- Implement proper access controls\n- Consider encryption for sensitive data\n\nSecure Alternative:\n```python\n# Use environment variables\nimport os\nPASSWORD = os.environ.get('APP_PASSWORD')\n```\n```\n\nKey Features:\n1. Dynamic Rule Loading\n2. Event-based Filtering\n3. Regex Pattern Matching\n4. Markdown-formatted Guidance\n5. Extensible Rule System\n6. JSON Rule Export\n\nRecommended Next Steps:\n- Create a `rules` directory\n- Add rule markdown files\n- Customize rule patterns and messages\n- Integrate with your specific use cases\n\nWould you like me to elaborate on any part of the implementation or discuss how to customize and extend this rule system?",
  "criteria_results": {
    "response_exists": true
  },
  "verification_notes": {
    "response_exists": "verified"
  },
  "verification_level": "full",
  "verified_criteria": {
    "passed": 1,
    "total": 1
  },
  "passed": true,
  "tokens": {
    "input": 148,
    "output": 1571,
    "total": 1719
  },
  "execution_time": 25.95213484764099,
  "error": null,
  "timestamp": "2026-01-01T19:20:31.664962"
}