{
  "task_id": "payload_hard_3",
  "prompt": "I'm having issues with my Payload hooks creating infinite loops when updating related records, and I also need to handle database transactions properly when creating orders with multiple line items. How do I prevent the loops and ensure data consistency?",
  "difficulty": "hard",
  "model": "claude-3-5-haiku-20241022",
  "response": "I'll help you solve both the infinite hook loop problem and ensure proper database transactions for order creation. Here's a comprehensive solution:\n\n```typescript\n// src/collections/Orders.ts\nimport type { CollectionConfig, Access } from 'payload/types'\nimport type { Order, LineItem } from '@/payload-types'\n\nexport const Orders: CollectionConfig = {\n  slug: 'orders',\n  fields: [\n    {\n      name: 'lineItems',\n      type: 'array',\n      fields: [\n        { \n          name: 'product', \n          type: 'relationship', \n          relationTo: 'products',\n          required: true \n        },\n        { \n          name: 'quantity', \n          type: 'number', \n          required: true,\n          min: 1\n        }\n      ]\n    },\n    { \n      name: 'total', \n      type: 'number',\n      admin: {\n        readOnly: true\n      }\n    },\n    { \n      name: 'status', \n      type: 'select', \n      options: [\n        { label: 'Pending', value: 'pending' },\n        { label: 'Processing', value: 'processing' },\n        { label: 'Completed', value: 'completed' },\n        { label: 'Cancelled', value: 'cancelled' }\n      ],\n      defaultValue: 'pending'\n    }\n  ],\n  hooks: {\n    beforeChange: [\n      async ({ data, operation, req }) => {\n        // Prevent infinite loops by checking context\n        if (req.context?.skipCalculateTotal) return data\n\n        // Calculate total for the order\n        if (data.lineItems && data.lineItems.length > 0) {\n          const total = await calculateOrderTotal(req.payload, data.lineItems)\n          data.total = total\n        }\n\n        return data\n      }\n    ],\n    afterChange: [\n      async ({ doc, operation, req }) => {\n        // Prevent infinite loops by checking context\n        if (req.context?.skipInventoryUpdate) return\n\n        // Update inventory after order creation/update\n        if (operation === 'create' || operation === 'update') {\n          await updateProductInventory(req.payload, doc, req)\n        }\n      }\n    ]\n  }\n}\n\n// Prevent infinite loops with context-aware functions\nasync function calculateOrderTotal(payload, lineItems) {\n  let total = 0\n  \n  for (const item of lineItems) {\n    // Fetch product with context to avoid recursive calls\n    const product = await payload.findByID({\n      collection: 'products',\n      id: item.product,\n      depth: 0, // Prevent deep population\n      context: { skipCalculateTotal: true }\n    })\n    \n    total += product.price * item.quantity\n  }\n  \n  return total\n}\n\nasync function updateProductInventory(payload, order, req) {\n  // Use context to prevent hook loops\n  const updatePromises = order.lineItems.map(async (item) => {\n    const product = await payload.findByID({\n      collection: 'products',\n      id: item.product,\n      depth: 0\n    })\n\n    // Safely update inventory\n    await payload.update({\n      collection: 'products',\n      id: item.product,\n      data: {\n        inventory: product.inventory - item.quantity\n      },\n      context: { \n        skipInventoryUpdate: true,\n        skipCalculateTotal: true \n      },\n      req\n    })\n  })\n\n  await Promise.all(updatePromises)\n}\n\n// Access control for orders\nexport const orderAccess: Access = ({ req: { user } }) => {\n  if (!user) return false\n\n  // Admin can see all orders\n  if (user.roles?.includes('admin')) return true\n\n  // Users can only see their own orders\n  return {\n    user: { equals: user.id }\n  }\n}\n```\n\nLet's break down the key strategies:\n\n### 1. Preventing Infinite Loops\n- Use `req.context` to add flags that prevent recursive hook calls\n- `skipInventoryUpdate` and `skipCalculateTotal` context flags stop repeated trigger of hooks\n- Pass `context` in every related operation\n\n### 2. Atomic Database Operations\n- Use `req` parameter in all payload operations to ensure they're part of the same transaction\n- Use `Promise.all()` for parallel safe updates\n- Fetch minimal data with `depth: 0` to avoid unnecessary population\n\n### 3. Access Control\n- Implement row-level security with `orderAccess`\n- Restrict order viewing/editing based on user roles\n\n### 4. Transaction Safety\n- Each operation passes `req` to maintain transaction context\n- Context flags prevent unintended recursive updates\n- Careful management of related record updates\n\n### Example Usage in API Route\n\n```typescript\n// src/app/api/create-order/route.ts\nimport { getPayload } from 'payload'\nimport config from '@/payload.config'\n\nexport async function POST(req: Request) {\n  const payload = await getPayload({ config })\n  const orderData = await req.json()\n\n  try {\n    const order = await payload.create({\n      collection: 'orders',\n      data: orderData,\n      req: { user: req.user } // Important for access control and transactions\n    })\n\n    return Response.json(order, { status: 201 })\n  } catch (error) {\n    console.error('Order creation failed:', error)\n    return Response.json({ error: 'Order creation failed' }, { status: 500 })\n  }\n}\n```\n\n### Best Practices Demonstrated\n- Explicit context management\n- Preventing hook loops\n- Safe inventory updates\n- Transactional integrity\n- Type-safe operations\n- Minimal data fetching\n\n### Additional Recommendations\n1. Always pass `req` in payload operations\n2. Use context flags liberally\n3. Keep hook logic minimal and focused\n4. Use `depth: 0` when full population isn't needed\n5. Handle errors gracefully\n6. Implement comprehensive access control\n\nThis approach ensures your Payload CMS hooks remain performant, prevent infinite loops, and maintain data consistency across related records.\n\nWould you like me to elaborate on any part of the implementation or discuss any specific requirements for your project?",
  "criteria_results": {
    "code_extracted": true,
    "has_type_annotations": true
  },
  "verification_notes": {
    "code_extracted": "verified",
    "has_type_annotations": "verified"
  },
  "verification_level": "full",
  "verified_criteria": {
    "passed": 2,
    "total": 2
  },
  "passed": true,
  "tokens": {
    "input": 4289,
    "output": 1521,
    "total": 5810
  },
  "execution_time": 25.40151882171631,
  "error": null,
  "timestamp": "2026-01-01T19:09:08.300614"
}