{
  "task_id": "typescript-write_hard_3",
  "prompt": "Create a comprehensive TypeScript testing utility that can mock API responses, simulate user interactions, and validate component behavior. Include generic types for flexible test data creation.",
  "difficulty": "hard",
  "model": "claude-3-5-haiku-20241022",
  "response": "I'll create a comprehensive TypeScript testing utility that provides robust mocking, interaction simulation, and component behavior validation. I'll break this down into multiple files to create a complete testing framework.\n\nLet's start with the project structure:\n\n```\n/src\n\u251c\u2500\u2500 testing\n\u2502   \u251c\u2500\u2500 mocks\n\u2502   \u2502   \u251c\u2500\u2500 api-mock.ts\n\u2502   \u2502   \u251c\u2500\u2500 data-generator.ts\n\u2502   \u2502   \u2514\u2500\u2500 event-simulator.ts\n\u2502   \u251c\u2500\u2500 assertions\n\u2502   \u2502   \u251c\u2500\u2500 component-validator.ts\n\u2502   \u2502   \u2514\u2500\u2500 async-validator.ts\n\u2502   \u2514\u2500\u2500 index.ts\n```\n\n1. Data Generation Utility (src/testing/mocks/data-generator.ts):\n```typescript\ntype PrimitiveType = string | number | boolean | null | undefined;\n\nexport class DataGenerator<T> {\n  /**\n   * Generate mock data with optional overrides\n   * @param template Base template for data generation\n   * @param overrides Partial overrides for specific fields\n   */\n  static create<T>(template: Partial<T> = {}): T {\n    return {\n      ...this.generateDefaultValues(template),\n      ...template\n    };\n  }\n\n  /**\n   * Generate an array of mock data\n   * @param count Number of items to generate\n   * @param template Base template for data generation\n   */\n  static createList<T>(count: number, template: Partial<T> = {}): T[] {\n    return Array.from({ length: count }, () => this.create(template));\n  }\n\n  /**\n   * Generate default values for missing fields\n   * @param template Existing template\n   */\n  private static generateDefaultValues<T>(template: Partial<T>): T {\n    const defaults: Record<string, () => PrimitiveType> = {\n      id: () => Math.random().toString(36).substr(2, 9),\n      name: () => `Test ${Math.random().toString(36).substr(2, 5)}`,\n      email: () => `test-${Math.random().toString(36).substr(2, 5)}@example.com`,\n      isActive: () => Math.random() > 0.5,\n      createdAt: () => new Date().toISOString()\n    };\n\n    const generatedDefaults: Partial<T> = {};\n    \n    Object.keys(defaults).forEach(key => {\n      if (!(key in template)) {\n        (generatedDefaults as any)[key] = defaults[key]();\n      }\n    });\n\n    return generatedDefaults as T;\n  }\n}\n```\n\n2. API Mocking Utility (src/testing/mocks/api-mock.ts):\n```typescript\nimport axios from 'axios';\nimport MockAdapter from 'axios-mock-adapter';\n\nexport class ApiMock {\n  private static instance: MockAdapter;\n\n  /**\n   * Initialize API mocking\n   */\n  static init(): MockAdapter {\n    if (!this.instance) {\n      this.instance = new MockAdapter(axios);\n    }\n    return this.instance;\n  }\n\n  /**\n   * Mock a GET request\n   * @param url URL to mock\n   * @param responseData Response data\n   * @param status HTTP status code\n   */\n  static mockGet<T>(url: string, responseData: T, status = 200) {\n    this.init().onGet(url).reply(status, responseData);\n  }\n\n  /**\n   * Mock a POST request\n   * @param url URL to mock\n   * @param responseData Response data\n   * @param status HTTP status code\n   */\n  static mockPost<T, R>(url: string, responseData: R, status = 200) {\n    this.init().onPost(url).reply(status, responseData);\n  }\n\n  /**\n   * Reset all mocks\n   */\n  static reset() {\n    if (this.instance) {\n      this.instance.reset();\n    }\n  }\n}\n```\n\n3. Event Simulation Utility (src/testing/mocks/event-simulator.ts):\n```typescript\nexport class EventSimulator {\n  /**\n   * Simulate a click event\n   * @param element Target element\n   */\n  static click(element: HTMLElement | null) {\n    if (!element) {\n      throw new Error('Element not found');\n    }\n    \n    const clickEvent = new MouseEvent('click', {\n      bubbles: true,\n      cancelable: true,\n      view: window\n    });\n    \n    element.dispatchEvent(clickEvent);\n  }\n\n  /**\n   * Simulate input change\n   * @param input Input element\n   * @param value New value\n   */\n  static input(input: HTMLInputElement | null, value: string) {\n    if (!input) {\n      throw new Error('Input element not found');\n    }\n    \n    input.value = value;\n    const event = new Event('input', { bubbles: true });\n    input.dispatchEvent(event);\n  }\n\n  /**\n   * Simulate form submission\n   * @param form Form element\n   */\n  static submitForm(form: HTMLFormElement | null) {\n    if (!form) {\n      throw new Error('Form element not found');\n    }\n    \n    const submitEvent = new Event('submit', {\n      bubbles: true,\n      cancelable: true\n    });\n    \n    form.dispatchEvent(submitEvent);\n  }\n}\n```\n\n4. Component Validator (src/testing/assertions/component-validator.ts):\n```typescript\nexport class ComponentValidator {\n  /**\n   * Check if element exists\n   * @param element Element to check\n   */\n  static exists(element: HTMLElement | null): boolean {\n    return !!element;\n  }\n\n  /**\n   * Validate text content\n   * @param element Element to check\n   * @param expectedText Expected text content\n   */\n  static hasText(element: HTMLElement | null, expectedText: string): boolean {\n    if (!element) return false;\n    return element.textContent?.trim() === expectedText.trim();\n  }\n\n  /**\n   * Check for CSS class\n   * @param element Element to check\n   * @param className Class to verify\n   */\n  static hasClass(element: HTMLElement | null, className: string): boolean {\n    if (!element) return false;\n    return element.classList.contains(className);\n  }\n\n  /**\n   * Validate attribute value\n   * @param element Element to check\n   * @param attributeName Attribute name\n   * @param expectedValue Expected attribute value\n   */\n  static hasAttribute(\n    element: HTMLElement | null, \n    attributeName: string, \n    expectedValue?: string\n  ): boolean {\n    if (!element) return false;\n    \n    const attributeValue = element.getAttribute(attributeName);\n    \n    return expectedValue \n      ? attributeValue === expectedValue \n      : !!attributeValue;\n  }\n}\n```\n\n5. Async Validator (src/testing/assertions/async-validator.ts):\n```typescript\nexport class AsyncValidator {\n  /**\n   * Wait for a condition to be true\n   * @param condition Condition to check\n   * @param timeout Maximum wait time\n   */\n  static async waitFor(\n    condition: () => boolean, \n    timeout = 5000\n  ): Promise<boolean> {\n    const startTime = Date.now();\n\n    return new Promise((resolve, reject) => {\n      const checkCondition = () => {\n        if (condition()) {\n          resolve(true);\n        } else if (Date.now() - startTime > timeout) {\n          reject(new Error('Condition not met within timeout'));\n        } else {\n          setTimeout(checkCondition, 50);\n        }\n      };\n\n      checkCondition();\n    });\n  }\n\n  /**\n   * Retry an async operation\n   * @param operation Operation to retry\n   * @param maxRetries Maximum number of retries\n   */\n  static async retry<T>(\n    operation: () => Promise<T>, \n    maxRetries = 3\n  ): Promise<T> {\n    let lastError: Error | undefined;\n\n    for (let attempt = 1; attempt <= maxRetries; attempt++) {\n      try {\n        return await operation();\n      } catch (error) {\n        lastError = error as Error;\n        await new Promise(resolve => setTimeout(resolve, 1000 * attempt));\n      }\n    }\n\n    throw lastError;\n  }\n}\n```\n\n6. Index File (src/testing/index.ts):\n```typescript\nexport { DataGenerator } from './mocks/data-generator';\nexport { ApiMock } from './mocks/api-mock';\nexport { EventSimulator } from './mocks/event-simulator';\nexport { ComponentValidator } from './assertions/component-validator';\nexport { AsyncValidator } from './assertions/async-validator';\n```\n\nExample Usage:\n```typescript\nimport { \n  DataGenerator, \n  ApiMock, \n  EventSimulator, \n  ComponentValidator, \n  AsyncValidator \n} from './testing';\n\n// Generate mock user data\nconst mockUser = DataGenerator.create<User>({ \n  name: 'John Doe',\n  email: 'john@example.com'\n});\n\n// Mock API response\nApiMock.mockGet('/api/users', [mockUser]);\n\n// Simulate user interaction\nEventSimulator.click(document.querySelector('#submit-button'));\n\n// Validate component\nconst userElement = document.querySelector('.user-profile');\nexpect(ComponentValidator.hasText(userElement, 'John Doe')).toBe(true);\n\n// Wait for async operation\nawait AsyncValidator.waitFor(() => {\n  return document.querySelector('.loading') === null;\n});\n```\n\nKey Features:\n1. Generic data generation with smart defaults\n2. API mocking with flexible response handling\n3. Event simulation for user interactions\n4. Component and async validation utilities\n5. Flexible and type-safe design\n\nThis comprehensive testing utility provides a robust framework for creating complex, type-safe tests in TypeScript with excellent developer experience and flexibility.\n\nDependencies to install:\n```bash\nnpm install --save-dev axios axios-mock-adapter @types/jest\n```\n\nRecommendations:\n- Use with Jest or Vitest\n- Customize default generation logic as needed\n- Extend utilities for specific project requirements\n\nWould you like me to elaborate on any part of the testing utility?",
  "criteria_results": {
    "code_extracted": true,
    "code_compiles": true,
    "has_type_annotations": false
  },
  "verification_notes": {
    "code_extracted": "verified",
    "code_compiles": "unverified - no unknown compiler available",
    "has_type_annotations": "verified"
  },
  "verification_level": "partial",
  "verified_criteria": {
    "passed": 1,
    "total": 2
  },
  "passed": false,
  "tokens": {
    "input": 167,
    "output": 2498,
    "total": 2665
  },
  "execution_time": 32.94591808319092,
  "error": null,
  "timestamp": "2026-01-01T17:10:16.068987"
}