{
  "prompt": "Design a TypeScript utility for form validation that can handle different field types and custom validation rules.",
  "baseline_response": "Here's a comprehensive TypeScript utility for form validation with flexible and extensible features:\n\n```typescript\n// Types and Interfaces\ntype ValidationRule = (value: any) => boolean | string;\ntype ValidationRules = Record<string, ValidationRule[]>;\n\ninterface ValidationResult {\n  isValid: boolean;\n  errors: Record<string, string[]>;\n}\n\ninterface FormField {\n  value: any;\n  rules: ValidationRule[];\n}\n\nclass FormValidator {\n  private fields: Record<string, FormField> = {};\n\n  // Add a field with validation rules\n  addField(name: string, value: any, rules: ValidationRule[] = []): void {\n    this.fields[name] = { value, rules };\n  }\n\n  // Add multiple fields at once\n  addFields(fields: Record<string, { value: any; rules?: ValidationRule[] }>): void {\n    Object.entries(fields).forEach(([name, { value, rules = [] }]) => {\n      this.addField(name, value, rules);\n    });\n  }\n\n  // Predefined validation rules\n  static rules = {\n    // Required field\n    required: (errorMessage: string = 'This field is required') => \n      (value: any) => {\n        const isValid = value !== null && value !== undefined && value !== '';\n        return isValid || errorMessage;\n      },\n\n    // Minimum length\n    minLength: (min: number, errorMessage?: string) => \n      (value: any) => {\n        const message = errorMessage || `Minimum length is ${min} characters`;\n        return (value && value.length >= min) || message;\n      },\n\n    // Maximum length\n    maxLength: (max: number, errorMessage?: string) => \n      (value: any) => {\n        const message = errorMessage || `Maximum length is ${max} characters`;\n        return (value && value.length <= max) || message;\n      },\n\n    // Email validation\n    email: (errorMessage: string = 'Invalid email format') => \n      (value: string) => {\n        const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n        return emailRegex.test(value) || errorMessage;\n      },\n\n    // Numeric validation\n    numeric: (errorMessage: string = 'Must be a number') => \n      (value: any) => {\n        return !isNaN(Number(value)) || errorMessage;\n      },\n\n    // Custom regex pattern\n    pattern: (regex: RegExp, errorMessage: string = 'Invalid format') => \n      (value: string) => {\n        return regex.test(value) || errorMessage;\n      },\n\n    // Range validation for numbers\n    range: (min: number, max: number, errorMessage?: string) => \n      (value: number) => {\n        const message = errorMessage || `Value must be between ${min} and ${max}`;\n        return (value >= min && value <= max) || message;\n      }\n  };\n\n  // Validate all fields\n  validate(): ValidationResult {\n    const errors: Record<string, string[]> = {};\n\n    Object.entries(this.fields).forEach(([fieldName, field]) => {\n      const fieldErrors: string[] = [];\n\n      // Run all validation rules for the field\n      field.rules.forEach(rule => {\n        const result = rule(field.value);\n        if (result !== true) {\n          fieldErrors.push(result as string);\n        }\n      });\n\n      // Store errors if any\n      if (fieldErrors.length > 0) {\n        errors[fieldName] = fieldErrors;\n      }\n    });\n\n    return {\n      isValid: Object.keys(errors).length === 0,\n      errors\n    };\n  }\n\n  // Clear all fields\n  reset(): void {\n    this.fields = {};\n  }\n}\n\n// Example usage\nfunction demonstrateFormValidation() {\n  const validator = new FormValidator();\n\n  // Add fields with validation rules\n  validator.addFields({\n    username: {\n      value: 'john_doe',\n      rules: [\n        FormValidator.rules.required(),\n        FormValidator.rules.minLength(3),\n        FormValidator.rules.maxLength(20)\n      ]\n    },\n    email: {\n      value: 'john@example.com',\n      rules: [\n        FormValidator.rules.required(),\n        FormValidator.rules.email()\n      ]\n    },\n    age: {\n      value: 25,\n      rules: [\n        FormValidator.rules.required(),\n        FormValidator.rules.numeric(),\n        FormValidator.rules.range(18, 100)\n      ]\n    },\n    // Custom validation rule\n    customField: {\n      value: 'custom value',\n      rules: [\n        (value) => value.includes('value') || 'Must contain the word \"value\"'\n      ]\n    }\n  });\n\n  // Validate the form\n  const validationResult = validator.validate();\n\n  console.log('Is Valid:', validationResult.isValid);\n  console.log('Errors:', validationResult.errors);\n}\n\n// Run the demonstration\ndemonstrateFormValidation();\n```\n\nThis form validation utility provides several key features:\n\n1. **Flexible Validation Rules**:\n   - Predefined rules like `required`, `minLength`, `maxLength`, `email`, `numeric`, etc.\n   - Support for custom validation rules\n   - Ability to add custom error messages\n\n2. **Multiple Field Validation**:\n   - Add single or multiple fields with validation rules\n   - Validate all fields at once\n   - Comprehensive error reporting\n\n3. **Extensible Design**:\n   - Static `rules` object for easy addition of new validation rules\n   - Chainable and configurable validation rules\n   - Type-safe implementation with TypeScript\n\n4. **Validation Result**:\n   - Returns a `ValidationResult` object with:\n     - `isValid` boolean flag\n     - `errors` object with field-specific error messages\n\n**Usage Example**:\n```typescript\nconst validator = new FormValidator();\nvalidator.addFields({\n  username: {\n    value: 'john_doe',\n    rules: [\n      FormValidator.rules.required(),\n      FormValidator.rules.minLength(3)\n    ]\n  },\n  email: {\n    value: 'invalid-email',\n    rules: [\n      FormValidator.rules.required(),\n      FormValidator.rules.email()\n    ]\n  }\n});\n\nconst result = validator.validate();\nconsole.log(result.isValid);  // false\nconsole.log(result.errors);   // { email: ['Invalid email format'] }\n```\n\nThe utility is highly flexible, allowing easy extension and customization of validation rules while providing a clean and type-safe API.\n\nKey improvements could include:\n- Adding async validation support\n- Integrating with form libraries\n- Supporting nested object validation\n- Adding more predefined validation rules",
  "baseline_tokens": {
    "input": 26,
    "output": 1658,
    "total": 1684
  },
  "skill_response": "I'll create a comprehensive form validation utility in TypeScript that provides flexible and extensible validation capabilities. I'll break this down into several components to create a robust solution.\n\n```typescript\n// types.ts\nexport type ValidationRule<T> = (value: T) => boolean | string;\n\nexport interface ValidationSchema<T> {\n  [key: string]: {\n    value: T;\n    rules: ValidationRule<T>[];\n  };\n}\n\nexport interface ValidationResult {\n  isValid: boolean;\n  errors: Record<string, string[]>;\n}\n\n// validation-rules.ts\nexport class ValidationRules {\n  // Common built-in validation rules\n  static required<T>(errorMessage: string = 'This field is required'): ValidationRule<T> {\n    return (value: T) => {\n      if (value === null || value === undefined || value === '') {\n        return errorMessage;\n      }\n      return true;\n    };\n  }\n\n  static minLength(min: number, errorMessage?: string): ValidationRule<string> {\n    return (value: string) => {\n      if (!value || value.length < min) {\n        return errorMessage || `Minimum length is ${min} characters`;\n      }\n      return true;\n    };\n  }\n\n  static maxLength(max: number, errorMessage?: string): ValidationRule<string> {\n    return (value: string) => {\n      if (value && value.length > max) {\n        return errorMessage || `Maximum length is ${max} characters`;\n      }\n      return true;\n    };\n  }\n\n  static email(errorMessage: string = 'Invalid email format'): ValidationRule<string> {\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    return (value: string) => {\n      return emailRegex.test(value) || errorMessage;\n    };\n  }\n\n  static pattern(regex: RegExp, errorMessage: string): ValidationRule<string> {\n    return (value: string) => {\n      return regex.test(value) || errorMessage;\n    };\n  }\n\n  static custom<T>(\n    validationFn: (value: T) => boolean | string, \n    errorMessage: string\n  ): ValidationRule<T> {\n    return (value: T) => {\n      const result = validationFn(value);\n      return result === true || result;\n    };\n  }\n}\n\n// form-validator.ts\nexport class FormValidator {\n  private schema: ValidationSchema<any>;\n\n  constructor(schema: ValidationSchema<any>) {\n    this.schema = schema;\n  }\n\n  validate(): ValidationResult {\n    const errors: Record<string, string[]> = {};\n    let isValid = true;\n\n    Object.entries(this.schema).forEach(([field, { value, rules }]) => {\n      const fieldErrors: string[] = [];\n\n      rules.forEach((rule) => {\n        const ruleResult = rule(value);\n        \n        if (ruleResult !== true) {\n          isValid = false;\n          fieldErrors.push(ruleResult as string);\n        }\n      });\n\n      if (fieldErrors.length > 0) {\n        errors[field] = fieldErrors;\n      }\n    });\n\n    return {\n      isValid,\n      errors,\n    };\n  }\n}\n\n// Example usage\nexport function exampleFormValidation() {\n  // Create a validation schema\n  const registrationSchema: ValidationSchema<any> = {\n    username: {\n      value: 'john_doe',\n      rules: [\n        ValidationRules.required('Username is required'),\n        ValidationRules.minLength(3, 'Username must be at least 3 characters'),\n        ValidationRules.maxLength(20, 'Username must be less than 20 characters')\n      ]\n    },\n    email: {\n      value: 'john@example.com',\n      rules: [\n        ValidationRules.required('Email is required'),\n        ValidationRules.email('Invalid email format')\n      ]\n    },\n    password: {\n      value: 'password123',\n      rules: [\n        ValidationRules.required('Password is required'),\n        ValidationRules.minLength(8, 'Password must be at least 8 characters'),\n        ValidationRules.custom(\n          (value) => /[A-Z]/.test(value), \n          'Password must contain an uppercase letter'\n        )\n      ]\n    }\n  };\n\n  // Validate the form\n  const validator = new FormValidator(registrationSchema);\n  const result = validator.validate();\n\n  console.log('Is Valid:', result.isValid);\n  console.log('Errors:', result.errors);\n}\n```\n\nKey Features of this Validation Utility:\n\n1. **Flexible Validation Rules**\n   - Provides built-in validation rules like `required`, `minLength`, `maxLength`, `email`, etc.\n   - Supports custom validation rules\n   - Each rule can have a custom error message\n\n2. **Type-Safe**\n   - Uses TypeScript generics to ensure type safety\n   - Can validate different types of form fields\n\n3. **Comprehensive Validation**\n   - Supports multiple rules per field\n   - Collects all validation errors, not just the first one\n\n4. **Easy to Use**\n   - Simple, declarative validation schema\n   - Straightforward validation process\n\nExample Usage Walkthrough:\n```typescript\n// Create a schema with validation rules\nconst schema = {\n  username: {\n    value: 'john',\n    rules: [\n      ValidationRules.required(),\n      ValidationRules.minLength(3)\n    ]\n  }\n};\n\n// Validate\nconst validator = new FormValidator(schema);\nconst result = validator.validate();\n\n// Check validation results\nif (!result.isValid) {\n  // Handle validation errors\n  console.log(result.errors);\n}\n```\n\nPotential Improvements:\n- Add more built-in validation rules\n- Support async validation\n- Create form binding helpers for frameworks like React or Vue\n- Add internationalization support for error messages\n\nThis utility provides a robust, flexible, and type-safe approach to form validation in TypeScript, allowing developers to easily define and enforce validation rules across different types of form inputs.",
  "skill_tokens": {
    "input": 129,
    "output": 1489,
    "total": 1618
  },
  "judge_verdict": "with_skill",
  "judge_reasoning": "Response A provides better TypeScript practices with proper generic typing (ValidationRule<T>), more structured code organization with separate files, and better type safety. While Response B has a more complete implementation visible, Response A demonstrates superior architecture with generic types that ensure type safety across different field types, which is crucial for a TypeScript utility. Response A's approach with ValidationSchema<T> and generic validation rules is more robust and maintainable than Response B's use of 'any' types.",
  "judge_model": "claude-sonnet-4-20250514",
  "timestamp": "2026-01-01T17:13:28.392687"
}