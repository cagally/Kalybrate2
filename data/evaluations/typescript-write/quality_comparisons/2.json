{
  "prompt": "Build a TypeScript interface and implementation for a notification system that supports different message types and priorities.",
  "baseline_response": "Here's a comprehensive TypeScript implementation of a notification system with support for different message types and priorities:\n\n```typescript\n// Enums for message types and priorities\nenum NotificationType {\n  INFO = 'info',\n  WARNING = 'warning',\n  ERROR = 'error',\n  SUCCESS = 'success'\n}\n\nenum NotificationPriority {\n  LOW = 1,\n  MEDIUM = 2,\n  HIGH = 3,\n  CRITICAL = 4\n}\n\n// Interface for notification message\ninterface INotification {\n  id: string;\n  type: NotificationType;\n  message: string;\n  priority: NotificationPriority;\n  timestamp: Date;\n  metadata?: Record<string, any>;\n}\n\n// Interface for notification service\ninterface INotificationService {\n  send(notification: INotification): void;\n  subscribe(\n    callback: (notification: INotification) => void,\n    filter?: (notification: INotification) => boolean\n  ): () => void;\n  getNotifications(\n    filter?: (notification: INotification) => boolean\n  ): INotification[];\n  clearNotifications(filter?: (notification: INotification) => boolean): void;\n}\n\n// Notification service implementation\nclass NotificationService implements INotificationService {\n  private notifications: INotification[] = [];\n  private subscribers: Array<{\n    callback: (notification: INotification) => void;\n    filter?: (notification: INotification) => boolean;\n  }> = [];\n\n  // Send a new notification\n  send(notification: INotification): void {\n    // Generate unique ID if not provided\n    if (!notification.id) {\n      notification.id = this.generateUniqueId();\n    }\n\n    // Set timestamp if not provided\n    if (!notification.timestamp) {\n      notification.timestamp = new Date();\n    }\n\n    // Store notification\n    this.notifications.push(notification);\n\n    // Notify subscribers\n    this.notifySubscribers(notification);\n  }\n\n  // Subscribe to notifications with optional filtering\n  subscribe(\n    callback: (notification: INotification) => void,\n    filter?: (notification: INotification) => boolean\n  ): () => void {\n    const subscription = { callback, filter };\n    this.subscribers.push(subscription);\n\n    // Return unsubscribe function\n    return () => {\n      const index = this.subscribers.indexOf(subscription);\n      if (index !== -1) {\n        this.subscribers.splice(index, 1);\n      }\n    };\n  }\n\n  // Get notifications with optional filtering\n  getNotifications(\n    filter?: (notification: INotification) => boolean\n  ): INotification[] {\n    if (filter) {\n      return this.notifications.filter(filter);\n    }\n    return [...this.notifications];\n  }\n\n  // Clear notifications with optional filtering\n  clearNotifications(filter?: (notification: INotification) => boolean): void {\n    if (filter) {\n      this.notifications = this.notifications.filter(n => !filter(n));\n    } else {\n      this.notifications = [];\n    }\n  }\n\n  // Notify subscribers matching the notification\n  private notifySubscribers(notification: INotification): void {\n    this.subscribers.forEach(subscriber => {\n      // Check if no filter or filter passes\n      if (!subscriber.filter || subscriber.filter(notification)) {\n        subscriber.callback(notification);\n      }\n    });\n  }\n\n  // Generate unique ID for notifications\n  private generateUniqueId(): string {\n    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n}\n\n// Example usage\nfunction demonstrateNotificationSystem() {\n  // Create notification service\n  const notificationService = new NotificationService();\n\n  // Subscribe to all notifications\n  const allSubscription = notificationService.subscribe(notification => {\n    console.log('All Notification:', notification);\n  });\n\n  // Subscribe to high-priority error notifications\n  const criticalErrorSubscription = notificationService.subscribe(\n    notification => {\n      console.log('Critical Error:', notification);\n    },\n    notification =>\n      notification.type === NotificationType.ERROR &&\n      notification.priority === NotificationPriority.CRITICAL\n  );\n\n  // Send various notifications\n  notificationService.send({\n    type: NotificationType.INFO,\n    message: 'System initialized',\n    priority: NotificationPriority.LOW\n  });\n\n  notificationService.send({\n    type: NotificationType.WARNING,\n    message: 'Low disk space',\n    priority: NotificationPriority.MEDIUM,\n    metadata: { diskUsage: '90%' }\n  });\n\n  notificationService.send({\n    type: NotificationType.ERROR,\n    message: 'Critical database connection failure',\n    priority: NotificationPriority.CRITICAL,\n    metadata: { errorCode: 'DB_CONN_001' }\n  });\n\n  // Get notifications\n  const criticalNotifications = notificationService.getNotifications(\n    notification => notification.priority === NotificationPriority.CRITICAL\n  );\n  console.log('Critical Notifications:', criticalNotifications);\n\n  // Unsubscribe\n  allSubscription();\n  criticalErrorSubscription();\n}\n\n// Run demonstration\ndemonstrateNotificationSystem();\n```\n\nThis implementation provides a robust notification system with the following features:\n\n1. **Enums for Types and Priorities**:\n   - `NotificationType`: Defines different types of notifications\n   - `NotificationPriority`: Defines priority levels\n\n2. **Notification Interface**:\n   - Includes properties like ID, type, message, priority, timestamp, and optional metadata\n\n3. **Notification Service**:\n   - `send()`: Send new notifications\n   - `subscribe()`: Subscribe to notifications with optional filtering\n   - `getNotifications()`: Retrieve notifications with optional filtering\n   - `clearNotifications()`: Clear notifications\n\n4. **Key Capabilities**:\n   - Unique ID generation\n   - Timestamp tracking\n   - Subscriber filtering\n   - Metadata support\n   - Unsubscribe functionality\n\n5. **Example Usage**:\n   - Demonstrates subscribing to all notifications\n   - Shows filtering for specific notification types and priorities\n   - Illustrates sending different types of notifications\n\n**Usage Example**:\n```typescript\n// Create service\nconst service = new NotificationService();\n\n// Subscribe to all notifications\nservice.subscribe(notification => {\n  console.log(notification);\n});\n\n// Subscribe to critical errors\nservice.subscribe(\n  notification => {\n    // Handle critical errors\n  },\n  notification => \n    notification.type === NotificationType.ERROR && \n    notification.priority === NotificationPriority.CRITICAL\n);\n\n// Send a notification\nservice.send({\n  type: NotificationType.WARNING,\n  message: 'System warning',\n  priority: NotificationPriority.MEDIUM\n});\n```\n\nThis implementation provides a flexible and type-safe notification system that can be easily extended and integrated into various applications.",
  "baseline_tokens": {
    "input": 26,
    "output": 1681,
    "total": 1707
  },
  "skill_response": "I'll help you create a TypeScript interface and implementation for a notification system with support for different message types and priorities. I'll break this down into multiple files to demonstrate a clean, modular approach.\n\n1. First, let's define an enum for message types and priorities:\n\n```typescript\n// src/notifications/types.ts\nexport enum NotificationType {\n  INFO = 'info',\n  WARNING = 'warning',\n  ERROR = 'error',\n  SUCCESS = 'success'\n}\n\nexport enum NotificationPriority {\n  LOW = 1,\n  MEDIUM = 2,\n  HIGH = 3,\n  CRITICAL = 4\n}\n```\n\n2. Next, let's create an interface for the notification:\n\n```typescript\n// src/notifications/interfaces.ts\nimport { NotificationType, NotificationPriority } from './types';\n\nexport interface Notification {\n  id: string;\n  message: string;\n  type: NotificationType;\n  priority: NotificationPriority;\n  timestamp: number;\n  duration?: number;\n}\n\nexport interface NotificationOptions {\n  type?: NotificationType;\n  priority?: NotificationPriority;\n  duration?: number;\n}\n```\n\n3. Now, let's implement the notification service:\n\n```typescript\n// src/notifications/service.ts\nimport { v4 as uuidv4 } from 'uuid';\nimport { Notification, NotificationOptions } from './interfaces';\nimport { NotificationType, NotificationPriority } from './types';\n\nexport class NotificationService {\n  private static instance: NotificationService;\n  private notifications: Notification[] = [];\n  private subscribers: Array<(notification: Notification) => void> = [];\n\n  private constructor() {}\n\n  // Singleton pattern\n  public static getInstance(): NotificationService {\n    if (!NotificationService.instance) {\n      NotificationService.instance = new NotificationService();\n    }\n    return NotificationService.instance;\n  }\n\n  // Create a new notification\n  public create(\n    message: string, \n    options: NotificationOptions = {}\n  ): Notification {\n    const notification: Notification = {\n      id: uuidv4(),\n      message,\n      type: options.type || NotificationType.INFO,\n      priority: options.priority || NotificationPriority.LOW,\n      timestamp: Date.now(),\n      duration: options.duration || 5000 // Default 5 seconds\n    };\n\n    this.notifications.push(notification);\n    this.notifySubscribers(notification);\n\n    return notification;\n  }\n\n  // Remove a notification by ID\n  public remove(id: string): void {\n    this.notifications = this.notifications.filter(\n      notification => notification.id !== id\n    );\n  }\n\n  // Get all notifications\n  public getAll(): Notification[] {\n    return [...this.notifications];\n  }\n\n  // Get notifications by type\n  public getByType(type: NotificationType): Notification[] {\n    return this.notifications.filter(\n      notification => notification.type === type\n    );\n  }\n\n  // Get notifications by priority\n  public getByPriority(priority: NotificationPriority): Notification[] {\n    return this.notifications.filter(\n      notification => notification.priority >= priority\n    );\n  }\n\n  // Subscribe to notifications\n  public subscribe(\n    callback: (notification: Notification) => void\n  ): () => void {\n    this.subscribers.push(callback);\n    \n    // Return unsubscribe function\n    return () => {\n      this.subscribers = this.subscribers.filter(\n        subscriber => subscriber !== callback\n      );\n    };\n  }\n\n  // Notify subscribers when a new notification is created\n  private notifySubscribers(notification: Notification): void {\n    this.subscribers.forEach(subscriber => subscriber(notification));\n  }\n\n  // Clear all notifications\n  public clear(): void {\n    this.notifications = [];\n  }\n}\n```\n\n4. Example usage:\n\n```typescript\n// src/example.ts\nimport { NotificationService } from './notifications/service';\nimport { NotificationType, NotificationPriority } from './notifications/types';\n\n// Get the singleton instance\nconst notificationService = NotificationService.getInstance();\n\n// Subscribe to notifications\nconst unsubscribe = notificationService.subscribe((notification) => {\n  console.log('New notification:', notification);\n});\n\n// Create notifications\nconst infoNotification = notificationService.create(\n  'Welcome to the system', \n  { \n    type: NotificationType.INFO, \n    priority: NotificationPriority.LOW \n  }\n);\n\nconst errorNotification = notificationService.create(\n  'Critical error occurred', \n  { \n    type: NotificationType.ERROR, \n    priority: NotificationPriority.CRITICAL \n  }\n);\n\n// Get all notifications\nconsole.log(notificationService.getAll());\n\n// Get high priority notifications\nconsole.log(notificationService.getByPriority(NotificationPriority.HIGH));\n\n// Remove a specific notification\nnotificationService.remove(infoNotification.id);\n\n// Unsubscribe from notifications\nunsubscribe();\n\n// Clear all notifications\nnotificationService.clear();\n```\n\nThis implementation provides a robust notification system with the following features:\n- Supports different notification types and priorities\n- Singleton pattern for global access\n- Subscription model for real-time notification handling\n- Methods to create, remove, filter, and manage notifications\n- Unique ID generation for each notification\n- Configurable duration and options\n\nKey design principles:\n- Modular structure with separate files for types, interfaces, and service\n- Use of TypeScript enums for type safety\n- Singleton pattern for consistent global state\n- Flexible options for notification creation\n- Immutable operations to prevent unintended side effects\n\nTo use this in a project, you'd need to:\n1. Install dependencies (e.g., `uuid` for ID generation)\n2. Import and use the `NotificationService`\n3. Integrate with your UI framework for displaying notifications\n\nWould you like me to elaborate on any part of the implementation?",
  "skill_tokens": {
    "input": 129,
    "output": 1447,
    "total": 1576
  },
  "judge_verdict": "without_skill",
  "judge_reasoning": "Response B provides a more complete and functional implementation. While Response A shows good modular structure with separate files, it's incomplete (cuts off mid-implementation). Response B delivers a fully working notification system with comprehensive interfaces, complete implementation including subscription management with filtering, notification storage, and proper method signatures. Response B also includes useful features like metadata support and filtering capabilities that make it more practical for real-world use.",
  "judge_model": "claude-sonnet-4-20250514",
  "timestamp": "2026-01-01T17:13:28.390106"
}