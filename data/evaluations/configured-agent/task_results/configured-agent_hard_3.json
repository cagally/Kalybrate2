{
  "task_id": "configured-agent_hard_3",
  "prompt": "I have multiple processing modules that each need different configuration parameters from the same YAML frontmatter file. Can you create a system that reads the config once and distributes the appropriate settings to each processing module?",
  "difficulty": "hard",
  "model": "claude-3-5-haiku-20241022",
  "response": "I'll provide a comprehensive solution that demonstrates reading a shared configuration file and distributing settings to multiple processing modules. Here's a complete implementation:\n\n```python\nimport yaml\nimport os\nfrom typing import Dict, Any\n\nclass ConfigManager:\n    def __init__(self, config_path: str = '.claude/my-plugin.local.md'):\n        \"\"\"\n        Initialize ConfigManager to read and distribute configuration\n        \n        :param config_path: Path to the configuration file\n        \"\"\"\n        self.config = self._load_config(config_path)\n    \n    def _load_config(self, config_path: str) -> Dict[str, Any]:\n        \"\"\"\n        Load configuration from YAML frontmatter\n        \n        :param config_path: Path to the configuration file\n        :return: Parsed configuration dictionary\n        \"\"\"\n        try:\n            with open(config_path, 'r') as file:\n                # Read entire file content\n                content = file.read()\n                \n                # Extract YAML frontmatter (between first two ---)\n                import re\n                match = re.search(r'^---\\n(.*?)\\n---', content, re.DOTALL)\n                \n                if match:\n                    yaml_content = match.group(1)\n                    return yaml.safe_load(yaml_content) or {}\n                return {}\n        except FileNotFoundError:\n            print(f\"Configuration file not found: {config_path}\")\n            return {}\n        except yaml.YAMLError as e:\n            print(f\"Error parsing YAML configuration: {e}\")\n            return {}\n    \n    def get_module_config(self, module_name: str) -> Dict[str, Any]:\n        \"\"\"\n        Retrieve configuration for a specific module\n        \n        :param module_name: Name of the module to get config for\n        :return: Module-specific configuration dictionary\n        \"\"\"\n        return self.config.get(module_name, {})\n\n\nclass DataProcessor:\n    def __init__(self, config_manager: ConfigManager):\n        \"\"\"\n        Base data processor that uses shared configuration\n        \n        :param config_manager: ConfigManager instance\n        \"\"\"\n        self.config_manager = config_manager\n    \n    def process(self):\n        \"\"\"\n        Template method to be implemented by subclasses\n        \"\"\"\n        raise NotImplementedError(\"Subclasses must implement process method\")\n\n\nclass ImageProcessor(DataProcessor):\n    def __init__(self, config_manager: ConfigManager):\n        super().__init__(config_manager)\n        # Get image-specific configuration\n        self.image_config = self.config_manager.get_module_config('image_processing')\n    \n    def process(self):\n        \"\"\"\n        Process images using module-specific configuration\n        \"\"\"\n        print(\"Image Processing Configuration:\")\n        print(self.image_config)\n        \n        # Example processing logic using configuration\n        resize_mode = self.image_config.get('resize_mode', 'scale')\n        max_width = self.image_config.get('max_width', 1024)\n        \n        print(f\"Resizing images with mode: {resize_mode}\")\n        print(f\"Maximum width: {max_width} pixels\")\n\n\nclass TextProcessor(DataProcessor):\n    def __init__(self, config_manager: ConfigManager):\n        super().__init__(config_manager)\n        # Get text-specific configuration\n        self.text_config = self.config_manager.get_module_config('text_processing')\n    \n    def process(self):\n        \"\"\"\n        Process text using module-specific configuration\n        \"\"\"\n        print(\"Text Processing Configuration:\")\n        print(self.text_config)\n        \n        # Example processing logic using configuration\n        language = self.text_config.get('language', 'en')\n        sentiment_threshold = self.text_config.get('sentiment_threshold', 0.5)\n        \n        print(f\"Processing text in language: {language}\")\n        print(f\"Sentiment analysis threshold: {sentiment_threshold}\")\n\n\ndef main():\n    # Ensure configuration directory exists\n    os.makedirs('.claude', exist_ok=True)\n    \n    # Create sample configuration file\n    sample_config = \"\"\"\n---\nimage_processing:\n  resize_mode: crop\n  max_width: 2048\n  quality: 90\n\ntext_processing:\n  language: en-US\n  sentiment_threshold: 0.7\n  max_tokens: 512\n---\n\"\"\"\n    \n    # Write sample configuration\n    with open('.claude/my-plugin.local.md', 'w') as f:\n        f.write(sample_config)\n    \n    # Create config manager\n    config_manager = ConfigManager()\n    \n    # Create and process different modules\n    image_processor = ImageProcessor(config_manager)\n    text_processor = TextProcessor(config_manager)\n    \n    # Process each module\n    image_processor.process()\n    print(\"\\n\")\n    text_processor.process()\n\n\nif __name__ == '__main__':\n    main()\n```\n\nThis solution provides:\n\n1. A `ConfigManager` class that:\n   - Reads YAML frontmatter from a configuration file\n   - Provides method to retrieve module-specific configurations\n\n2. A base `DataProcessor` class that:\n   - Takes a `ConfigManager` instance\n   - Provides a template for processing modules\n\n3. Specific processor classes (`ImageProcessor` and `TextProcessor`) that:\n   - Inherit from `DataProcessor`\n   - Retrieve and use their specific configurations\n\n4. A `main()` function that:\n   - Creates a sample configuration file\n   - Demonstrates configuration distribution\n   - Runs processing for different modules\n\nKey features:\n- Centralized configuration management\n- Flexible, extensible design\n- Error handling for configuration loading\n- Type hinting for better code clarity\n\nSample configuration file (`.claude/my-plugin.local.md`):\n```yaml\n---\nimage_processing:\n  resize_mode: crop\n  max_width: 2048\n  quality: 90\n\ntext_processing:\n  language: en-US\n  sentiment_threshold: 0.7\n  max_tokens: 512\n---\n```\n\nWhen you run this script, it will:\n1. Create a sample configuration file\n2. Read the configuration\n3. Distribute settings to different processing modules\n4. Print out the module-specific configurations and example processing steps\n\nThis approach allows you to:\n- Centralize configuration management\n- Easily add new processing modules\n- Maintain a clean, modular architecture",
  "criteria_results": {
    "code_extracted": true
  },
  "verification_notes": {
    "code_extracted": "verified"
  },
  "verification_level": "full",
  "verified_criteria": {
    "passed": 1,
    "total": 1
  },
  "passed": true,
  "tokens": {
    "input": 186,
    "output": 1537,
    "total": 1723
  },
  "execution_time": 22.000177145004272,
  "error": null,
  "timestamp": "2026-01-01T18:08:49.985798"
}