{
  "prompt": "Design a Clojure API for a library management system with book checkout, return, and inventory tracking features.",
  "baseline_response": "Here's a comprehensive Clojure API design for a library management system:\n\n```clojure\n(ns library-management.core\n  (:require [clojure.spec.alpha :as s]\n            [java-time :as jt]))\n\n;; Specs for data validation\n(s/def ::isbn string?)\n(s/def ::title string?)\n(s/def ::author string?)\n(s/def ::genre string?)\n(s/def ::published-year int?)\n(s/def ::total-copies pos-int?)\n(s/def ::available-copies nat-int?)\n\n;; Book record definition\n(defrecord Book [isbn title author genre published-year total-copies available-copies])\n\n;; Member record definition\n(defrecord Member [id name email contact-number])\n\n;; Library system state\n(defonce library-state \n  (atom \n   {:books {}\n    :members {}\n    :checkout-records {}}))\n\n;; Protocols for library operations\n(defprotocol BookManagement\n  (add-book [this book])\n  (remove-book [this isbn])\n  (update-book [this isbn updates])\n  (get-book [this isbn]))\n\n(defprotocol MemberManagement\n  (register-member [this member])\n  (update-member [this member-id updates])\n  (remove-member [this member-id])\n  (get-member [this member-id]))\n\n(defprotocol CheckoutManagement\n  (checkout-book [this isbn member-id])\n  (return-book [this isbn member-id])\n  (get-checkout-history [this member-id])\n  (get-overdue-books [this]))\n\n;; Implementation of library management protocols\n(deftype LibrarySystem [state]\n  BookManagement\n  (add-book [this book]\n    (when (s/valid? (s/keys :req-un [::isbn ::title ::author ::genre \n                                     ::published-year ::total-copies]) book)\n      (swap! state update-in [:books (:isbn book)] \n             (fn [_] (map->Book (assoc book :available-copies (:total-copies book)))))\n      book))\n  \n  (remove-book [this isbn]\n    (swap! state update :books dissoc isbn)\n    isbn)\n  \n  (update-book [this isbn updates]\n    (swap! state update-in [:books isbn] merge updates)\n    (get-in @state [:books isbn]))\n  \n  (get-book [this isbn]\n    (get-in @state [:books isbn]))\n\n  MemberManagement\n  (register-member [this member]\n    (let [member-id (or (:id member) (java.util.UUID/randomUUID))]\n      (swap! state assoc-in [:members member-id] \n             (assoc member :id member-id))\n      member))\n  \n  (update-member [this member-id updates]\n    (swap! state update-in [:members member-id] merge updates)\n    (get-in @state [:members member-id]))\n  \n  (remove-member [this member-id]\n    (swap! state update :members dissoc member-id)\n    member-id)\n  \n  (get-member [this member-id]\n    (get-in @state [:members member-id]))\n\n  CheckoutManagement\n  (checkout-book [this isbn member-id]\n    (let [book (get-in @state [:books isbn])\n          member (get-in @state [:members member-id])]\n      (when (and book member (pos? (:available-copies book)))\n        (swap! state \n               (fn [current-state]\n                 (-> current-state\n                     (update-in [:books isbn :available-copies] dec)\n                     (assoc-in [:checkout-records \n                                (java.util.UUID/randomUUID)] \n                               {:isbn isbn\n                                :member-id member-id\n                                :checkout-date (jt/local-date)\n                                :due-date (jt/plus (jt/local-date) (jt/days 14))\n                                :returned? false}))))\n        true)))\n  \n  (return-book [this isbn member-id]\n    (let [checkout-record \n          (first \n           (filter \n            #(and (= (:isbn %) isbn) \n                  (= (:member-id %) member-id)\n                  (false? (:returned? %)))\n            (vals (:checkout-records @state))))]\n      (when checkout-record\n        (swap! state \n               (fn [current-state]\n                 (-> current-state\n                     (update-in [:books isbn :available-copies] inc)\n                     (assoc-in \n                      [:checkout-records \n                       (first \n                        (keep \n                         (fn [[k v]] \n                           (when (= v checkout-record) k)) \n                        (:checkout-records current-state))) \n                       :returned?] \n                      true))))\n        true)))\n  \n  (get-checkout-history [this member-id]\n    (filter #(= (:member-id %) member-id) \n            (vals (:checkout-records @state))))\n  \n  (get-overdue-books [this]\n    (filter \n     #(and (false? (:returned? %))\n           (jt/before? (:due-date %) (jt/local-date))) \n     (vals (:checkout-records @state)))))\n\n;; Constructor function\n(defn create-library-system []\n  (LibrarySystem. library-state))\n\n;; Utility functions\n(defn search-books \n  \"Search books by various criteria\"\n  [library-system criteria]\n  (let [all-books (vals (get @(:state library-system) :books))]\n    (filter \n     (fn [book]\n       (every? \n        (fn [[k v]] \n          (= (get book k) v)) \n        criteria)) \n     all-books)))\n\n;; Example usage\n(comment\n  (def library (create-library-system))\n  \n  ;; Add a book\n  (add-book library \n            {:isbn \"1234567890\" \n             :title \"Clojure Programming\" \n             :author \"Carin Meier\" \n             :genre \"Technical\" \n             :published-year 2012 \n             :total-copies 5})\n  \n  ;; Register a member\n  (register-member library \n                   {:name \"John Doe\" \n                    :email \"john@example.com\" \n                    :contact-number \"1234567890\"})\n  \n  ;; Checkout a book\n  (checkout-book library \"1234567890\" member-id)\n  \n  ;; Return a book\n  (return-book library \"1234567890\" member-id)\n  \n  ;; Search books\n  (search-books library {:genre \"Technical\"}))\n```\n\nThis library management system provides a comprehensive API with the following key features:\n\n1. **Data Validation**:\n   - Uses `clojure.spec` for data validation\n   - Ensures type and structure correctness for books and members\n\n2. **Core Protocols**:\n   - `BookManagement`: Add, remove, update, and retrieve books\n   - `MemberManagement`: Register, update, remove, and retrieve members\n   - `CheckoutManagement`: Handle book checkouts, returns, and tracking\n\n3. **Key Functions**:\n   - `checkout-book`: Handles book checkout with validation\n   - `return-book`: Processes book returns\n   - `get-overdue-books`: Retrieves currently overdue books\n   - `search-books`: Flexible book search by various criteria\n\n4. **State Management**:\n   - Uses an atom to manage library state\n   - Tracks books, members, and checkout records\n\n5. **Additional Features**:\n   - Automatic UUID generation for books and members\n   - Date tracking for checkouts and due dates\n   - Checkout history tracking\n\nExample improvements and extensions could include:\n\n- Adding more sophisticated search capabilities\n- Implementing fine calculation for overdue books\n- Adding authentication and authorization\n- Creating more complex checkout rules\n\nTo use the library, create an instance with `(create-library-system)` and use the provided methods to manage books, members, and checkouts.\n\nThe design follows Clojure's functional programming principles, uses immutable data structures, and provides a clean, composable API for library management.",
  "baseline_tokens": {
    "input": 30,
    "output": 2069,
    "total": 2099
  },
  "skill_response": "I'll help you design a Clojure library management system API using a REPL-driven development approach. I'll break this down into multiple namespaces and incrementally develop the core functionality.\n\nLet's start with the core design:\n\n```clojure\n(ns library-management.core\n  (:require [clojure.spec.alpha :as s]\n            [clojure.spec.gen.alpha :as gen]))\n\n;; Specs for data validation\n(s/def ::book-id uuid?)\n(s/def ::title string?)\n(s/def ::author string?)\n(s/def ::isbn string?)\n(s/def ::genre keyword?)\n\n(s/def ::book \n  (s/keys :req [::book-id \n                ::title \n                ::author \n                ::isbn \n                ::genre]))\n\n(s/def ::patron-id uuid?)\n(s/def ::name string?)\n(s/def ::email string?)\n\n(s/def ::patron \n  (s/keys :req [::patron-id \n                ::name \n                ::email]))\n\n(s/def ::checkout-date inst?)\n(s/def ::due-date inst?)\n```\n\nNext, let's create the book repository namespace:\n\n```clojure\n(ns library-management.book-repository\n  (:require [library-management.core :as core]\n            [clojure.spec.alpha :as s]))\n\n(defprotocol BookRepository\n  \"Protocol for book management operations\"\n  (add-book [this book])\n  (remove-book [this book-id])\n  (find-book-by-id [this book-id])\n  (find-books-by-genre [this genre])\n  (update-book-status [this book-id status]))\n\n(defrecord InMemoryBookRepository [books]\n  BookRepository\n  (add-book [this book]\n    (when (s/valid? ::core/book book)\n      (swap! books conj book)\n      book))\n  \n  (remove-book [this book-id]\n    (swap! books (fn [current-books]\n                   (remove #(= (::core/book-id %) book-id) current-books))))\n  \n  (find-book-by-id [this book-id]\n    (first (filter #(= (::core/book-id %) book-id) @books)))\n  \n  (find-books-by-genre [this genre]\n    (filter #(= (::core/genre %) genre) @books))\n  \n  (update-book-status [this book-id status]\n    (swap! books \n           (fn [current-books]\n             (map (fn [book]\n                    (if (= (::core/book-id book) book-id)\n                      (assoc book ::status status)\n                      book))\n                  current-books)))))\n\n(defn create-book-repository []\n  (->InMemoryBookRepository (atom [])))\n```\n\nNow, the checkout management namespace:\n\n```clojure\n(ns library-management.checkout-management\n  (:require [library-management.core :as core]\n            [library-management.book-repository :as repo]\n            [clojure.spec.alpha :as s]\n            [java-time :as jt]))\n\n(defprotocol CheckoutManager\n  \"Protocol for managing book checkouts\"\n  (checkout-book [this patron-id book-id])\n  (return-book [this book-id])\n  (get-overdue-books [this]))\n\n(defrecord InMemoryCheckoutManager [checkouts book-repo]\n  CheckoutManager\n  (checkout-book [this patron-id book-id]\n    (let [book (repo/find-book-by-id book-repo book-id)]\n      (when book\n        (let [checkout-entry \n              {::core/book-id book-id\n               ::core/patron-id patron-id\n               ::core/checkout-date (jt/instant)\n               ::core/due-date (jt/plus (jt/instant) (jt/days 14))}]\n          (swap! checkouts conj checkout-entry)\n          (repo/update-book-status book-repo book-id :checked-out)\n          checkout-entry))))\n  \n  (return-book [this book-id]\n    (let [checkout (first (filter #(= (::core/book-id %) book-id) @checkouts))]\n      (when checkout\n        (swap! checkouts (fn [current-checkouts]\n                           (remove #(= (::core/book-id %) book-id) \n                                   current-checkouts)))\n        (repo/update-book-status book-repo book-id :available)\n        checkout)))\n  \n  (get-overdue-books [this]\n    (let [now (jt/instant)]\n      (filter (fn [checkout]\n                (jt/before? (::core/due-date checkout) now))\n              @checkouts))))\n\n(defn create-checkout-manager [book-repo]\n  (->InMemoryCheckoutManager (atom []) book-repo))\n```\n\nLet's create a library facade to tie everything together:\n\n```clojure\n(ns library-management.library\n  (:require [library-management.book-repository :as book-repo]\n            [library-management.checkout-management :as checkout]\n            [library-management.core :as core]\n            [clojure.spec.alpha :as s]))\n\n(defrecord Library [book-repository checkout-manager]\n  \n  ;; Book Management Methods\n  (add-book [this book]\n    (book-repo/add-book book-repository book))\n  \n  (find-book [this book-id]\n    (book-repo/find-book-by-id book-repository book-id))\n  \n  (remove-book [this book-id]\n    (book-repo/remove-book book-repository book-id))\n  \n  ;; Checkout Management Methods\n  (checkout-book [this patron-id book-id]\n    (checkout/checkout-book checkout-manager patron-id book-id))\n  \n  (return-book [this book-id]\n    (checkout/return-book checkout-manager book-id))\n  \n  (get-overdue-books [this]\n    (checkout/get-overdue-books checkout-manager)))\n\n(defn create-library []\n  (let [book-repository (book-repo/create-book-repository)\n        checkout-manager (checkout/create-checkout-manager book-repository)]\n    (->Library book-repository checkout-manager)))\n```\n\nExample Usage:\n\n```clojure\n(def library (create-library))\n\n;; Add a book\n(def book-1 \n  {::core/book-id (java.util.UUID/randomUUID)\n   ::core/title \"Clojure Programming\"\n   ::core/author \"Chas Emerick\"\n   ::core/isbn \"978-1449394707\"\n   ::core/genre :programming})\n\n(add-book library book-1)\n\n;; Checkout a book\n(def patron-1 \n  {::core/patron-id (java.util.UUID/randomUUID)\n   ::core/name \"John Doe\"\n   ::core/email \"john@example.com\"})\n\n(checkout-book library (::core/patron-id patron-1) (::core/book-id book-1))\n```\n\nKey Design Principles:\n1. Used protocols for flexibility and extensibility\n2. Implemented in-memory repositories for simplicity\n3. Used clojure.spec for data validation\n4. Followed functional programming principles\n5. Separated concerns between different namespaces\n\nPotential Improvements:\n- Persistent storage (database integration)\n- More robust error handling\n- Additional querying capabilities\n- Authentication and authorization\n- Reservation system\n\nWould you like me to elaborate on any part of the design or discuss potential extensions?",
  "skill_tokens": {
    "input": 886,
    "output": 1918,
    "total": 2804
  },
  "judge_verdict": "without_skill",
  "judge_reasoning": "Response A provides a more complete and practical API design with concrete implementations for all three required features (checkout, return, inventory tracking). It includes proper data structures, protocols, and implementation details for book management, member management, and checkout operations. Response B, while showing good architectural thinking with separate namespaces and protocols, is incomplete and cuts off mid-implementation, failing to demonstrate the checkout and return functionality that are core requirements of the task.",
  "judge_model": "claude-sonnet-4-20250514",
  "timestamp": "2026-01-01T17:58:59.409649"
}