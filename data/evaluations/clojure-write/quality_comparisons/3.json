{
  "prompt": "Implement a simple caching mechanism in Clojure with TTL support and automatic cleanup of expired entries.",
  "baseline_response": "Here's an implementation of a TTL (Time-To-Live) cache in Clojure with automatic cleanup of expired entries:\n\n```clojure\n(ns ttl-cache.core\n  (:import [java.util.concurrent ConcurrentHashMap]\n           [java.util.concurrent Executors TimeUnit]))\n\n(defprotocol Cache\n  \"Protocol for a TTL-based cache\"\n  (get-value [this key])\n  (put-value [this key value ttl])\n  (remove-value [this key])\n  (clear [this]))\n\n(deftype TTLCache [^ConcurrentHashMap cache \n                   ^ConcurrentHashMap expiration-map\n                   cleanup-interval]\n  Cache\n  (get-value [_ key]\n    (let [current-time (System/currentTimeMillis)]\n      (when-let [exp-time (get expiration-map key)]\n        (if (> exp-time current-time)\n          (.get cache key)\n          (do \n            (remove-value _ key)\n            nil)))))\n  \n  (put-value [_ key value ttl]\n    (let [exp-time (+ (System/currentTimeMillis) ttl)]\n      (.put cache key value)\n      (.put expiration-map key exp-time)))\n  \n  (remove-value [_ key]\n    (.remove cache key)\n    (.remove expiration-map key))\n  \n  (clear [_]\n    (.clear cache)\n    (.clear expiration-map))\n  \n  Object\n  (toString [_]\n    (str \"Cache contents: \" (into {} cache)\n         \"\\nExpiration times: \" (into {} expiration-map))))\n\n(defn create-ttl-cache \n  \"Create a new TTL cache with optional cleanup interval (in milliseconds)\"\n  ([] (create-ttl-cache 60000)) ; Default 1-minute cleanup interval\n  ([cleanup-interval]\n   (let [cache (TTLCache. \n                (ConcurrentHashMap.)\n                (ConcurrentHashMap.)\n                cleanup-interval)\n         cleanup-task \n         (fn []\n           (let [current-time (System/currentTimeMillis)]\n             (doseq [[key exp-time] (seq (.entrySet (.expiration-map-val cache)))]\n               (when (<= exp-time current-time)\n                 (remove-value cache key)))))]\n     \n     ;; Setup periodic cleanup\n     (let [scheduler (Executors/newScheduledThreadPool 1)]\n       (.scheduleAtFixedRate \n        scheduler \n        cleanup-task \n        cleanup-interval \n        cleanup-interval \n        TimeUnit/MILLISECONDS))\n     \n     cache)))\n\n;; Example usage\n(defn -main []\n  (let [cache (create-ttl-cache 5000)] ; 5-second cleanup interval\n    ;; Put values with different TTLs\n    (put-value cache :key1 \"value1\" 10000) ; 10-second TTL\n    (put-value cache :key2 \"value2\" 2000)  ; 2-second TTL\n    \n    ;; Immediate retrieval\n    (println \"Immediate get:\" (get-value cache :key1))\n    \n    ;; Wait and check\n    (Thread/sleep 3000)\n    (println \"After 3 seconds:\")\n    (println \"Key1:\" (get-value cache :key1))\n    (println \"Key2:\" (get-value cache :key2))\n    \n    ;; Wait more and check again\n    (Thread/sleep 5000)\n    (println \"After 8 seconds:\")\n    (println \"Key1:\" (get-value cache :key1))\n    (println \"Key2:\" (get-value cache :key2))))\n```\n\nLet's break down the key components:\n\n1. **Cache Protocol**:\n   - Defines basic cache operations: `get-value`, `put-value`, `remove-value`, and `clear`\n\n2. **TTLCache Implementation**:\n   - Uses two `ConcurrentHashMap`s:\n     - One for storing the actual cache values\n     - Another for storing expiration times\n   - `get-value` checks if the entry is still valid\n   - `put-value` adds a key with its value and expiration time\n   - `remove-value` removes both the value and its expiration time\n\n3. **Automatic Cleanup**:\n   - Uses a scheduled executor to periodically remove expired entries\n   - Configurable cleanup interval\n\n4. **Key Features**:\n   - Thread-safe (uses `ConcurrentHashMap`)\n   - Automatic expiration of entries\n   - Configurable TTL per entry\n   - Periodic cleanup of expired entries\n\nExample usage demonstrates:\n- Putting entries with different TTLs\n- Retrieving entries before and after expiration\n\nYou can customize the cache by:\n- Changing the cleanup interval\n- Modifying expiration logic\n- Adding more sophisticated eviction policies\n\nPotential improvements:\n- Add maximum cache size\n- Implement more advanced eviction strategies\n- Add more robust error handling\n\nHere's a more functional approach with slightly different implementation:\n\n```clojure\n(ns ttl-cache.functional\n  (:import [java.util.concurrent Executors TimeUnit]))\n\n(defn create-ttl-cache \n  \"Create a TTL cache with functional approach\"\n  ([] (create-ttl-cache 60000))\n  ([cleanup-interval]\n   (let [cache-atom (atom {})\n         expiration-atom (atom {})]\n     \n     ;; Periodic cleanup\n     (let [scheduler (Executors/newScheduledThreadPool 1)]\n       (.scheduleAtFixedRate \n        scheduler\n        (fn []\n          (let [current-time (System/currentTimeMillis)]\n            (swap! cache-atom \n                   (fn [cache]\n                     (reduce-kv \n                      (fn [m k v]\n                        (if (> (get @expiration-atom k 0) current-time)\n                          m\n                          (dissoc m k)))\n                      cache\n                      cache)))))\n        cleanup-interval \n        cleanup-interval \n        TimeUnit/MILLISECONDS))\n     \n     {:cache cache-atom\n      :expiration expiration-atom\n      :get (fn [key]\n             (let [current-time (System/currentTimeMillis)\n                   exp-time (get @expiration-atom key 0)]\n               (when (> exp-time current-time)\n                 (get @cache-atom key))))\n      :put (fn [key value ttl]\n             (let [exp-time (+ (System/currentTimeMillis) ttl)]\n               (swap! cache-atom assoc key value)\n               (swap! expiration-atom assoc key exp-time)))\n      :remove (fn [key]\n                (swap! cache-atom dissoc key)\n                (swap! expiration-atom dissoc key))\n      :clear (fn []\n               (reset! cache-atom {})\n               (reset! expiration-atom {}))})))\n\n;; Usage example\n(defn -main []\n  (let [cache (create-ttl-cache 5000)\n        get-fn (:get cache)\n        put-fn (:put cache)]\n    \n    (put-fn :key1 \"value1\" 10000)\n    (put-fn :key2 \"value2\" 2000)\n    \n    (println \"Immediate get:\" (get-fn :key1))\n    \n    (Thread/sleep 3000)\n    (println \"After 3 seconds:\")\n    (println \"Key1:\" (get-fn :key1))\n    (println \"Key2:\" (get-fn :key2))))\n```\n\nThis functional approach:\n- Uses atoms for managing state\n- Provides a map of functions for cache operations\n- Similar cleanup mechanism\n- More idiomatic Clojure style\n\nBoth implementations provide a flexible, thread-safe caching mechanism with TTL support and automatic cleanup.",
  "baseline_tokens": {
    "input": 30,
    "output": 1930,
    "total": 1960
  },
  "skill_response": "I'll implement a simple TTL (Time-To-Live) cache in Clojure with automatic cleanup. I'll break this down into a step-by-step REPL-driven development approach.\n\nLet's create a namespace for our cache implementation:\n\n```clojure\n(ns metabase.utils.ttl-cache\n  (:require [clojure.core.async :as async]))\n\n(defprotocol Cache\n  \"Protocol for a TTL-based cache\"\n  (get-item [this key] \"Retrieve an item from the cache\")\n  (put-item! [this key value ttl] \"Put an item in the cache with a TTL\")\n  (remove-item! [this key] \"Remove a specific item from the cache\"))\n\n(defrecord TTLCache [cache-atom cleaner-chan]\n  Cache\n  (get-item [this key]\n    (let [current-time (System/currentTimeMillis)\n          entry (get @cache-atom key)]\n      (when (and entry (< current-time (:expires-at entry)))\n        (:value entry))))\n  \n  (put-item! [this key value ttl]\n    (let [expires-at (+ (System/currentTimeMillis) ttl)]\n      (swap! cache-atom assoc key \n             {:value value \n              :expires-at expires-at})))\n  \n  (remove-item! [this key]\n    (swap! cache-atom dissoc key)))\n\n(defn create-ttl-cache \n  \"Create a new TTL cache with automatic cleanup\"\n  []\n  (let [cache-atom (atom {})\n        cleaner-chan (async/chan)\n        cleanup-interval 5000] ; Clean every 5 seconds\n    \n    ;; Start cleanup goroutine\n    (async/go-loop []\n      (let [current-time (System/currentTimeMillis)]\n        ;; Remove expired entries\n        (swap! cache-atom \n               (fn [m] \n                 (into {} \n                       (filter (fn [[_ v]] (> (:expires-at v) current-time)) \n                               m))))\n        \n        ;; Wait before next cleanup\n        (async/<! (async/timeout cleanup-interval))\n        (recur)))\n    \n    (->TTLCache cache-atom cleaner-chan)))\n\n;; Example usage and testing\n(defn test-ttl-cache []\n  (let [cache (create-ttl-cache)]\n    ;; Put an item that expires in 2 seconds\n    (put-item! cache :test-key \"test-value\" 2000)\n    \n    ;; Immediately retrieve should work\n    (println \"Immediate retrieve:\" (get-item cache :test-key))\n    \n    ;; Wait and check\n    (Thread/sleep 3000)\n    (println \"After expiration:\" (get-item cache :test-key))))\n\n;; Run the test\n(test-ttl-cache)\n```\n\nLet's break down the implementation:\n\n1. **Protocol Definition**:\n   - `Cache` protocol defines core operations: `get-item`, `put-item!`, and `remove-item!`\n\n2. **TTLCache Record**:\n   - Uses an atom to store cache entries\n   - Each entry has a value and an expiration timestamp\n   - `get-item` checks if the item exists and is not expired\n   - `put-item!` adds an item with a TTL\n   - `remove-item!` manually removes an item\n\n3. **Automatic Cleanup**:\n   - Uses `core.async` to create a background cleanup process\n   - Runs every 5 seconds\n   - Removes entries whose expiration time has passed\n\n4. **Key Features**:\n   - Threadsafe via `atom`\n   - Automatic expiration\n   - Simple interface\n   - Background cleanup\n\nTo test and verify, you can use the REPL:\n\n```clojure\n;; Create cache\n(def my-cache (create-ttl-cache))\n\n;; Add an item that expires in 2 seconds\n(put-item! my-cache :user-data {:name \"John\"} 2000)\n\n;; Immediate retrieval should work\n(get-item my-cache :user-data)\n;; => {:name \"John\"}\n\n;; Wait 3 seconds\n(Thread/sleep 3000)\n\n;; Retrieval after expiration should return nil\n(get-item my-cache :user-data)\n;; => nil\n```\n\n**Improvements and Considerations**:\n- Add logging for cleanup operations\n- Make cleanup interval configurable\n- Add maximum cache size limit\n- Potentially use `core.cache` library for more advanced caching strategies\n\n**Testing Recommendations**:\n- Write unit tests to verify:\n  1. Item retrieval before and after expiration\n  2. Multiple concurrent access\n  3. Cleanup mechanism works correctly\n\nWould you like me to elaborate on any part of the implementation or discuss potential extensions?",
  "skill_tokens": {
    "input": 886,
    "output": 1182,
    "total": 2068
  },
  "judge_verdict": "without_skill",
  "judge_reasoning": "Response A provides a more complete and robust implementation with proper Java interop using ConcurrentHashMap for thread safety, includes all required protocol methods, and has a more sophisticated cleanup mechanism using ScheduledExecutorService. Response B is incomplete (cuts off mid-implementation), uses less thread-safe atom operations, and relies on core.async which adds unnecessary complexity for this use case. Response A also includes better error handling and a more professional structure.",
  "judge_model": "claude-sonnet-4-20250514",
  "timestamp": "2026-01-01T17:58:59.409167"
}