{
  "task_id": "clojure-write_hard_3",
  "prompt": "I need to refactor a large legacy Clojure codebase that has grown organically. The main issues are deeply nested functions, poor separation of concerns, and lack of proper error handling. Can you help me restructure it following best practices?",
  "difficulty": "hard",
  "model": "claude-3-5-haiku-20241022",
  "response": "I'll help you refactor the Clojure codebase following best practices. I'll demonstrate a comprehensive refactoring approach with a practical example that addresses common legacy code issues.\n\nLet's create a typical scenario of a legacy data processing namespace that needs restructuring:\n\n```clojure\n;; Legacy Namespace: metabase.legacy-data-processing\n(ns metabase.legacy-data-processing\n  (:require [clojure.string :as str]\n            [clojure.data.json :as json]))\n\n;; Deeply nested, complex function with multiple responsibilities\n(defn process-user-data \n  \"Monolithic function doing too many things\"\n  [raw-data]\n  (try \n    (let [parsed-data (json/read-str raw-data :key-fn keyword)\n          validated-data \n          (if (and (map? parsed-data)\n                   (every? #(contains? parsed-data %) \n                           [:name :email :age]))\n            (-> parsed-data\n                (update :name str/trim)\n                (update :email str/lower-case)\n                (cond-> (< (:age parsed-data) 18)\n                  (assoc :user-type :minor)\n                  (>= (:age parsed-data) 18)\n                  (assoc :user-type :adult))\n                (dissoc :raw-input))\n            (throw (ex-info \"Invalid user data\" \n                    {:type :validation-error \n                     :input parsed-data})))\n          sanitized-data \n          (if (re-matches #\"[^@]+@[^@]+\" (:email validated-data))\n            validated-data\n            (throw (ex-info \"Invalid email format\" \n                    {:type :email-validation-error \n                     :email (:email validated-data)})))]\n      sanitized-data)\n    (catch Exception e\n      ;; Catch-all error handling\n      {:error (.getMessage e)})))\n```\n\nRefactored version with best practices:\n\n```clojure\n;; metabase.data-processing.core\n(ns metabase.data-processing.core\n  (:require [metabase.data-processing.validation :as validation]\n            [metabase.data-processing.sanitization :as sanitization]\n            [metabase.data-processing.transformations :as transformations]\n            [clojure.data.json :as json]\n            [clojure.tools.logging :as log]))\n\n;; Separate validation concerns\n(defn validate-user-data \n  \"Validate raw input data\"\n  [parsed-data]\n  (when-not (and (map? parsed-data)\n                 (every? #(contains? parsed-data %) \n                         [:name :email :age]))\n    (throw (ex-info \"Invalid user data structure\" \n             {:type :validation-error \n              :input parsed-data}))))\n\n;; Separate transformation concerns\n(defn transform-user-data \n  \"Transform validated user data\"\n  [parsed-data]\n  (-> parsed-data\n      (update :name str/trim)\n      (update :email str/lower-case)\n      (assoc :user-type \n             (if (< (:age parsed-data) 18) \n               :minor \n               :adult))\n      (dissoc :raw-input)))\n\n;; Separate sanitization concerns\n(defn sanitize-user-email \n  \"Validate email format\"\n  [email]\n  (when-not (re-matches #\"[^@]+@[^@]+\" email)\n    (throw (ex-info \"Invalid email format\" \n             {:type :email-validation-error \n              :email email}))))\n\n;; Compose functions with clear separation of concerns\n(defn process-user-data \n  \"Coordinated data processing with clear error handling\"\n  [raw-data]\n  (try \n    (let [parsed-data (json/read-str raw-data :key-fn keyword)]\n      (validate-user-data parsed-data)\n      (let [transformed-data (transform-user-data parsed-data)]\n        (sanitize-user-email (:email transformed-data))\n        transformed-data))\n    (catch clojure.lang.ExceptionInfo e\n      (log/error e \"User data processing failed\")\n      {:error (ex-message e)\n       :error-type (get (ex-data e) :type)})\n    (catch Exception e\n      (log/error e \"Unexpected error in user data processing\")\n      {:error \"Unexpected processing error\"\n       :details (.getMessage e)})))\n```\n\nKey Refactoring Principles Demonstrated:\n\n1. **Separation of Concerns**\n   - Split monolithic function into smaller, focused functions\n   - Each function has a single responsibility\n   - Clear function names describe their purpose\n\n2. **Improved Error Handling**\n   - Use `ex-info` for structured error reporting\n   - Specific exception types for different error scenarios\n   - Logging of errors\n   - Graceful error responses\n\n3. **Functional Composition**\n   - Functions are pure and easily testable\n   - Data flows through transformations\n   - No side effects in core processing functions\n\n4. **Modularity**\n   - Suggested namespace structure for related functions\n   - Easy to test individual components\n   - Flexible for future extensions\n\nRecommended Project Structure:\n```\nsrc/\n\u2514\u2500\u2500 metabase/\n    \u2514\u2500\u2500 data_processing/\n        \u251c\u2500\u2500 core.clj           # Main processing logic\n        \u251c\u2500\u2500 validation.clj      # Input validation functions\n        \u251c\u2500\u2500 sanitization.clj    # Data sanitization logic\n        \u2514\u2500\u2500 transformations.clj # Data transformation helpers\n```\n\nComplementary Test Approach:\n```clojure\n(ns metabase.data-processing.core-test\n  (:require [clojure.test :refer :all]\n            [metabase.data-processing.core :as data-proc]))\n\n(deftest user-data-processing-test\n  (testing \"Valid user data processing\"\n    (let [result (data-proc/process-user-data \n                   \"{\\\"name\\\":\\\"John Doe\\\", \\\"email\\\":\\\"john@example.com\\\", \\\"age\\\":25}\"))]\n      (is (= \"John Doe\" (:name result)))\n      (is (= \"john@example.com\" (:email result)))\n      (is (= :adult (:user-type result)))))\n\n  (testing \"Invalid user data handling\"\n    (let [result (data-proc/process-user-data \n                   \"{\\\"name\\\":\\\"Invalid\\\", \\\"email\\\":\\\"bad-email\\\"}\")]\n      (is (contains? result :error)))))\n```\n\nThis refactoring approach provides:\n- Clear, modular code\n- Better error handling\n- Improved testability\n- Easier future maintenance\n\nRecommendations for Large-Scale Refactoring:\n1. Refactor incrementally\n2. Maintain comprehensive test coverage\n3. Use REPL-driven development to validate changes\n4. Gradually replace legacy code\n\nWould you like me to elaborate on any specific aspect of the refactoring approach?",
  "criteria_results": {
    "code_extracted": true,
    "code_compiles": true
  },
  "verification_notes": {
    "code_extracted": "verified",
    "code_compiles": "unverified - no clojure compiler available"
  },
  "verification_level": "partial",
  "verified_criteria": {
    "passed": 1,
    "total": 1
  },
  "passed": true,
  "tokens": {
    "input": 941,
    "output": 1721,
    "total": 2662
  },
  "execution_time": 25.95154571533203,
  "error": null,
  "timestamp": "2026-01-01T17:54:44.677827"
}