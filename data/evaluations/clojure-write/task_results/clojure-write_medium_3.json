{
  "task_id": "clojure-write_medium_3",
  "prompt": "I have a data processing pipeline that needs to transform JSON data, validate it, and store results. Can you build this in Clojure using a functional approach?",
  "difficulty": "medium",
  "model": "claude-3-5-haiku-20241022",
  "response": "I'll create a functional Clojure pipeline for JSON data processing that demonstrates best practices and follows the REPL-driven development workflow. I'll break this down into a complete solution with validation, transformation, and storage.\n\n```clojure\n(ns data-pipeline.core\n  (:require \n   [clojure.data.json :as json]\n   [clojure.spec.alpha :as s]\n   [clojure.java.io :as io]))\n\n;; Data Specification\n(s/def ::id string?)\n(s/def ::name string?)\n(s/def ::age (s/and int? #(< 0 % 120)))\n(s/def ::email string?)\n\n(s/def ::person \n  (s/keys :req-un [::id ::name ::age ::email]))\n\n;; Transformation Functions\n(defn parse-json \n  \"Parse JSON string into Clojure map\"\n  [json-str]\n  (try \n    (json/read-str json-str :key-fn keyword)\n    (catch Exception e \n      (println \"JSON Parsing Error:\" (.getMessage e))\n      nil)))\n\n(defn validate-person \n  \"Validate person data using spec\"\n  [person-data]\n  (when (s/valid? ::person person-data)\n    person-data))\n\n(defn transform-person\n  \"Apply transformations to person data\"\n  [person]\n  (update person :name clojure.string/trim))\n\n(defn process-pipeline\n  \"Complete data processing pipeline\"\n  [json-str]\n  (->> json-str\n       parse-json\n       validate-person\n       transform-person))\n\n(defn save-processed-data\n  \"Save processed data to a file\"\n  [data output-path]\n  (when data\n    (spit output-path (json/write-str data))))\n\n;; Example Usage Function\n(defn process-json-file \n  \"Process entire JSON file\"\n  [input-path output-path]\n  (let [json-str (slurp input-path)\n        processed-data (process-pipeline json-str)]\n    (save-processed-data processed-data output-path)\n    processed-data))\n\n;; Example Test Data \n(def sample-json \n  \"{\\\"id\\\":\\\"123\\\", \\\"name\\\":\\\"  John Doe  \\\", \\\"age\\\":35, \\\"email\\\":\\\"john@example.com\\\"}\")\n\n;; Demo in REPL\n(comment \n  ;; Parse and validate JSON\n  (parse-json sample-json)\n  \n  ;; Full pipeline processing\n  (process-pipeline sample-json)\n  \n  ;; Process a file\n  (process-json-file \"input.json\" \"output.json\"))\n```\n\nLet me break down the key components of this functional Clojure data processing pipeline:\n\n1. **Data Specification**:\n   - Uses `clojure.spec` for robust data validation\n   - Defines specs for person data structure\n   - Validates ID, name, age, and email with type and range checks\n\n2. **Transformation Functions**:\n   - `parse-json`: Converts JSON string to Clojure map\n   - `validate-person`: Validates data against spec\n   - `transform-person`: Applies transformations (e.g., trimming whitespace)\n\n3. **Pipeline Function**:\n   - `process-pipeline`: Composes transformations using threading macro\n   - Handles parsing, validation, and transformation in a single function\n\n4. **File Processing**:\n   - `save-processed-data`: Writes processed data to a file\n   - `process-json-file`: Reads input file, processes data, saves output\n\n5. **Error Handling**:\n   - Uses `try-catch` for JSON parsing\n   - Returns `nil` for invalid data\n   - Leverages spec validation to ensure data integrity\n\nDependencies you'll need in `deps.edn`:\n```clojure\n{:deps \n {org.clojure/clojure {:mvn/version \"1.11.1\"}\n  org.clojure/data.json {:mvn/version \"2.4.0\"}\n  org.clojure/spec.alpha {:mvn/version \"0.3.218\"}}}\n```\n\nREPL Workflow Example:\n```clojure\n;; In REPL, you can interactively test each function\n(parse-json sample-json)\n;; => {:id \"123\", :name \"  John Doe  \", :age 35, :email \"john@example.com\"}\n\n(validate-person *1)\n;; => {:id \"123\", :name \"  John Doe  \", :age 35, :email \"john@example.com\"}\n\n(process-pipeline sample-json)\n;; => {:id \"123\", :name \"John Doe\", :age 35, :email \"john@example.com\"}\n```\n\nBest Practices Demonstrated:\n- Functional composition\n- Immutable data transformations\n- Spec-based validation\n- Error handling\n- Composable, small functions\n- Thread-first/thread-last macro usage\n\nPotential Improvements:\n- Add more robust error handling\n- Include logging\n- Create more complex transformation rules\n- Add multiple validation steps\n\nWould you like me to elaborate on any part of this data processing pipeline?",
  "criteria_results": {
    "code_extracted": true,
    "code_compiles": true
  },
  "verification_notes": {
    "code_extracted": "verified",
    "code_compiles": "unverified - no clojure compiler available"
  },
  "verification_level": "partial",
  "verified_criteria": {
    "passed": 1,
    "total": 1
  },
  "passed": true,
  "tokens": {
    "input": 923,
    "output": 1266,
    "total": 2189
  },
  "execution_time": 19.84855818748474,
  "error": null,
  "timestamp": "2026-01-01T17:54:44.676053"
}